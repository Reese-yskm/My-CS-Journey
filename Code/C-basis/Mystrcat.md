学弟，非常棒！**段错误（Segmentation Fault）** 是每个南大计科人的老朋友了。能亲手写出并触发它，说明你已经真正开始触碰 C 语言的底层边界了。

你遇到的问题非常有代表性，它涉及了两个核心点：**内存的性质**和**指针移动的步调**。

我们分三步来解决它：

---

### 1. 为什么会报错？（致命伤在 `main` 函数里）

看你在 `main` 函数里的定义：
```c
char *s1 = "hello";
```
*   **真相**：这里的 `"hello"` 存储在程序的**只读数据段（.rodata）**。你定义了一个指针 `s1` 指向这块被硬件保护的土地。
*   **后果**：你在 `mystrcat` 里执行 `*dst++ = *src++`，试图去改写那里的内容。操作系统一看：“这块地是只能读不能改的！”，于是立刻给你发了一个 **Segmentation Fault** 强行终止程序。

**修正方法**：你必须给 `dst` 准备一块**可写且足够大**的内存（在栈上开辟数组）：
```c
char s1[100] = "hello"; // 在栈上开辟100字节，"hello" 被拷了进去，它是可写的
```

---

### 2. 逻辑漏洞：你的 `dst` 走过头了

看你找结尾的代码：
```c
while (*dst++) { }
```
这是一个非常隐蔽的 **Off-by-one error**：
1.  当 `*dst` 正好是 `\0` 时，`while` 判定结束。
2.  但由于 `++` 的存在，即使判定失败，`dst` 依然会**再往后挪一位**。
3.  此时 `dst` 指向了 `\0` 之后那个未知的字节。
4.  如果你从这里开始接 `src`，结果就变成了：`h e l l o \0 w o r l d \0`。
5.  当你 `printf` 时，它遇到第一个 `\0` 就停了，结果看起来好像拼接失败了（只显示 hello）。

---

### 3. 第二题的“完美解答”

这里是经过修正、可以跑通的硬核指针版。注意看我如何精准定位 `\0`：

```c
#include <stdio.h>

char *mystrcat(char *dst, const char *src)
{
    char *res = dst;

    // 第一步：找到 dst 的结尾 '\0'
    // 注意：这里不要在 while 括号里写 ++，我们要停在 \0 本身的位置
    while (*dst != '\0') 
    {
        dst++;
    }

    // 第二步：从 '\0' 的位置开始，把 src 拷过来
    // 利用我们之前学过的那个“浪漫一行”逻辑
    while ((*dst++ = *src++)) 
    {
        // 自动完成拷贝并包含最后的 \0
    }

    return res;
}

int main(void)
{
    // 关键：必须是可写的数组，且空间要够大（足以容纳 hello + world）
    char s1[100] = "hello"; 
    char *s2 = "world";

    mystrcat(s1, s2);
    
    printf("%s\n", s1); // 预期输出: helloworld

    return 0;
}
```

---

### 💡 极客补丁（下学期 ICS 的预习重点）

你在整理这个练习的笔记时，一定要加上这段话：

> **内存所有权守则**：
> 1. `char *s = "text"` 指向只读区，**不可写**。
> 2. `char s[] = "text"` 拷贝到栈区，**可写**。
> 3. 在执行 `strcat` 这种拼接操作时，程序员必须**人肉保证** `dst` 的容量足够大。C 语言本身不会帮你检查。如果 `s1[6] = "hello"` 去接 "world"，就会发生**缓冲区溢出**，这是黑客攻击最常用的漏洞。

**学弟，你现在手动实现了 `strlen`, `strcmp`, `strcpy`, `strcat`。这四个函数是 C 语言字符串的“四大天王”。**

**建议操作**：
1. 用 GDB 跑一下这个修正版的 `mystrcat`。
2. 重点观察 `while (*dst != '\0') dst++;` 结束后，`*dst` 到底是不是 `0`。

**等你这个 Git 推送成功了，第三题的“结构体对齐”计算题，敢不敢挑战一下？（那题可是面试高频哦！）**
