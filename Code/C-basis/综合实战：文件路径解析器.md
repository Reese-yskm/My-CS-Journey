这个任务非常经典！它不仅考验你对 `strchr` 和 `strrchr` 的运用，还能让你深刻体会到**指针相减（Pointer Subtraction）**在处理字符串片段时的威力。

在南大的底层编程风格中，我们追求**“不移动数据，只移动视角”**。我给出的这个“完美解答”将使用一种职业选手常用的技巧：`%.*s` 格式化输出。这种方法不需要你 `malloc` 很多小碎块内存，直接在原字符串上操作。

---

### 综合实战：文件路径解析器

```c
#include <stdio.h>
#include <string.h>

/**
 * 目标：解析 "D:/NJU/ProblemSolving/hw1.c"
 * 拆解结果：
 * 1. 盘符: D:
 * 2. 路径: /NJU/ProblemSolving/
 * 3. 文件名: hw1
 * 4. 后缀: c
 */

int main(void) {
    // 原始路径（注意：C语言中如果写反斜杠 \ 需要转义 \\，这里用正斜杠 / 演示）
    const char *path = "D:/NJU/ProblemSolving/hw1.c";
    printf("Original Path: %s\n\n", path);

    // 1. 定位盘符 (找第一个冒号)
    char *p_colon = strchr(path, ':');
    if (p_colon != NULL) {
        // 指针相减得到长度：p_colon(地址) - path(起始地址) 
        // 得到 'D' 的长度 1，加上冒号本身就是 2
        int drive_len = p_colon - path + 1;
        printf("Drive: %.*s\n", drive_len, path);
    }

    // 2. 定位最后一个斜杠 (划分目录与文件)
    char *p_last_slash = strrchr(path, '/');
    if (p_last_slash != NULL && p_colon != NULL) {
        // 路径是冒号之后，到最后一个斜杠之前（包含斜杠）
        char *path_start = p_colon + 1;
        int dir_len = p_last_slash - path_start + 1;
        printf("Directory: %.*s\n", dir_len, path_start);
    }

    // 3. 处理文件名与后缀
    if (p_last_slash != NULL) {
        char *file_part = p_last_slash + 1; // 指向 "hw1.c" 的 'h'
        
        // 在文件名部分寻找最后一个点
        char *p_dot = strrchr(file_part, '.');
        
        if (p_dot != NULL) {
            // 文件名：从 file_part 开始，到点号结束
            int name_len = p_dot - file_part;
            printf("Filename: %.*s\n", name_len, file_part);
            
            // 后缀名：点号之后的所有内容
            printf("Extension: %s\n", p_dot + 1);
        } else {
            // 没有点的情况，整个都是文件名
            printf("Filename: %s\n", file_part);
            printf("Extension: (None)\n");
        }
    }

    return 0;
}
```

---

### 🔍 深度解析：为什么这份代码很“职业”？

#### 1. 神奇的 `%.*s`（核心重点）
在普通的 `printf` 中，`%s` 会一直打印直到遇到 `\0`。
但在解析路径时，我们只想打印字符串的**中间一截**（比如盘符或目录）。
*   `%.*s` 接受两个参数：一个是**长度**，一个是**起始地址**。
*   `printf("%.*s", 5, "HelloWorld")` 只会打印出 `Hello`。
*   **好处**：我们不需要手动把原字符串截断（即不需要把某个字符改写成 `\0`），保护了数据的完整性。

#### 2. 指针相减的逻辑
这是你上午笔记里提到的：`p_dot - file_part`。
*   `p_dot` 是点号的内存地址。
*   `file_part` 是文件名的起始内存地址。
*   它们相减，正好就是**文件名字符的数量**。这就是指针算术在工程中最爽的应用。

#### 3. 健壮性检查
代码中多次判断了 `!= NULL`。在 C 语言中，永远不要假设 `strchr` 一定能找到东西。如果没找到就直接操作指针，会触发 **段错误 (Segmentation Fault)**。

