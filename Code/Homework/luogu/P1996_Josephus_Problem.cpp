/**
 * ======================================================================================
 * @file    P1996_Josephus_Problem.cpp
 * @author  Reese_fan (NJU-CS)
 * @date    2026-03-01
 * @brief   洛谷 P1996 约瑟夫问题 - 队列模拟实现
 * ======================================================================================
 *
 * 【题目描述】
 * n 个人围成一圈，从第一个人开始报数，数到 m 的人出列，再由下一个人重新从 1 开始报数，
 * 数到 m 的人再出圈，依次类推，直到所有的人都出圈，请输出依次出圈人的编号。
 *
 * 输入格式：输入两个整数 n, m。 (1 <= n, m <= 100)
 * 输出格式：输出一行 n 个整数，按顺序输出每个出圈人的编号。
 *
 * 样例输入：10 3
 * 样例输出：3 6 9 2 7 1 8 5 10 4
 *
 * ======================================================================================
 * 【算法点拨：数据结构的直觉】
 *
 * 1. 物理模型抽象：
 *    约瑟夫环的本质是一个“循环移动”的过程。虽然物理上是一个圆圈，但逻辑上可以看作是一个
 *    “末尾衔接”的队列。
 *
 * 2. 核心思路 - 队列模拟 (Queue Rotation)：
 *    - 将 1 到 n 依次入队。
 *    - 报数循环：
 *        - 如果报数不到 m，就将队头元素弹出 (pop) 并重新压入队尾 (push)。
 *        - 如果报数恰好到 m，就将队头元素直接弹出并输出，不再放回队列。
 *
 * 3. 为什么选择 std::queue？
 *    - 数组：删除操作是 O(n)，且处理环形逻辑需要复杂的取模运算。
 *    - 链表：虽然删除是 O(1)，但手动维护循环链表指针极其容易出错。
 *    - 队列：天然支持 FIFO。通过“出队再入队”的操作，优雅地模拟了“环”的物理属性。
 *
 * ======================================================================================
 * 【职业连接：负载均衡 (Round Robin)】
 *
 * 在深圳互联网大厂（如腾讯、华为）的后端开发中，有一种基础算法叫“轮询调度 (Round Robin)”。
 * 当一个负载均衡器面对多台服务器时，它会维持一个队列，依次取出服务器处理请求，处理完后再
 * 放回队尾。这本质上就是不剔除成员的“约瑟夫环”。
 *
 * ======================================================================================
 */

#include <iostream>
#include <queue>
#include <vector>

using namespace std;

int main()
{
    // 性能优化：关闭同步流，提高输入输出效率
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int n, m;
    if (!(cin >> n >> m))
        return 0;

    // 使用队列作为容器，模拟圆圈
    queue<int> q;

    // 初始化：将所有人按编号 1..n 放入队列
    for (int i = 1; i <= n; i++)
    {
        q.push(i);
    }

    // 只要队列中还有人，就继续报数
    while (!q.empty())
    {
        // 进行 m-1 次模拟：还没轮到的人领个号，重新排到队尾
        for (int i = 1; i < m; i++)
        {
            int current = q.front();
            q.pop();
            q.push(current);
        }

        // 此时队头就是数到 m 的那个人
        cout << q.front();
        q.pop();

        // 格式控制：最后一个输出后面不带空格
        if (!q.empty())
        {
            cout << " ";
        }
    }

    cout << endl;

    return 0;
}

/**
 * 【反思总结】
 *
 * 1. 坚持的力量：通过这两天的学习，从图论最短路、最小生成树，到现在的基本线性数据结构，
 *    我深刻体会到“坚持”才是程序员最重要的算法。
 *
 * 2. 结构优于逻辑：选对了数据结构，复杂的逻辑（如模拟环形移动）会瞬间降维成简单的操作。
 *    这道题让我彻底记住了：循环逻辑 = 队列出队再入队。
 *
 * 3. 性能：虽然 O(n*m) 在这道题没问题，但要意识到数学方法（约瑟夫环递推公式）在处理
 *    超大规模数据时的优越性。不过在工程中，模拟法的可读性往往更好。
 */