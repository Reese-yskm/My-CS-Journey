/**
 * ======================================================================================
 * @file    P2234_Turnover_Statistics.cpp
 * @author  Reese_fan (NJU-CS)
 * @date    2026-03-01
 * @brief   洛谷 P2234 [HNOI2002] 营业额统计 - std::set + 哨兵(Sentinel)优化版
 * ======================================================================================
 *
 * 【题目描述 - P2234】
 * Tiger 担任营业部经理，需要分析公司成立以来的营业情况。
 * 定义：某天的“最小波动值” = min( |该天以前某天的营业额 - 该天营业额| )。
 * 特别地：第一天的最小波动值为第一天的营业额。
 * 任务：计算公司成立 n 天以来，每日最小波动值的总和。
 *
 * 数据范围：n <= 32767, 营业额 |ai| <= 10^6。
 *
 * ======================================================================================
 * 【算法建模：动态有序集合的最近邻查询】
 *
 * 1. 物理模型：
 *    我们需要在一个不断增加的数字集合中，快速找到与当前数 t 最接近的两个数：
 *    - 前驱 (Predecessor)：集合中最大的 < t 的数。
 *    - 后继 (Successor)：集合中最小的 >= t 的数。
 *
 * 2. 数据结构选型：std::set
 *    - std::set 内部基于红黑树，能够自动维持元素的有序性。
 *    - s.lower_bound(t) 可以在 O(log n) 时间内定位到第一个 >= t 的迭代器。
 *
 * ======================================================================================
 * 【深度对比：普通迭代器逻辑 vs. 哨兵优化逻辑】
 *
 * 方案 A：普通迭代器 (已弃用)
 * -------------------------------------------------------------------
 * if (it == s.begin()) {
 *     res += *it - t; // 只有右边
 * } else if (it == s.end()) {
 *     res += t - *prev(it); // 只有左边
 * } else {
 *     res += min(*it - t, t - *prev(it)); // 左右都有，取最小值
 * }
 * 痛点：逻辑分支多，且对 begin() 进行 --it 操作会导致运行时错误。
 *
 * 方案 B：哨兵优化 (当前采用)
 * -------------------------------------------------------------------
 * 在集合初始化时预埋两个极端值：s.insert(-1e9) 和 s.insert(1e9)。
 * 核心优势：
 * 1. 消除边界：因为有 -1e9，it 永远不会等于 begin()。
 * 2. 消除空查：因为有 1e9，it 永远不会等于 end()。
 * 3. 统一逻辑：所有情况都缩减为一行：min(*it - t, t - *prev(it))。
 *
 * ======================================================================================
 */

#include <iostream>
#include <set>
#include <algorithm>
#include <iterator> // 用于 std::prev

using namespace std;

// 定义哨兵值，需超出题目营业额范围 |-10^6|
const int INF = 1e9;

int main()
{
    // 性能优化：同步流优化
    ios::sync_with_stdio(false);
    cin.tie(NULL);

    int n;
    if (!(cin >> n))
        return 0;

    set<int> s;
    // 【哨兵技巧】预先插入极大和极小值，简化后续 lower_bound 的边界判断
    s.insert(-INF);
    s.insert(INF);

    long long total_fluctuation = 0;

    for (int i = 0; i < n; i++)
    {
        int val;
        cin >> val;

        if (i == 0)
        {
            // 第一天：根据题目定义，波动值等于营业额本身
            total_fluctuation += val;
        }
        else
        {
            // 核心操作：O(log n) 定位第一个 >= val 的位置
            auto it = s.lower_bound(val);

            // 【哨兵红利】
            // 此时 it 绝不会等于 s.begin() (因为有 -INF)
            // 此时 it 绝不会等于 s.end()   (因为有 INF)

            // 计算右侧邻居（第一个 >= val 的数）
            long long succ = *it;
            // 计算左侧邻居（通过 prev 获取前一个迭代器，即最大的 < val 的数）
            long long pred = *prev(it);

            // 统一计算最小差值，无需任何 if-else 判断边界
            total_fluctuation += min(succ - val, (long long)val - pred);
        }

        // 将今日营业额存入集合，供未来天数查询使用
        s.insert(val);
    }

    cout << total_fluctuation << endl;

    return 0;
}

/**
 * 【复杂度分析】
 * - 时间复杂度：O(n log n)。每日 insert 和 lower_bound 均为 O(log n)。
 * - 空间复杂度：O(n)。存储 n 个营业额。
 *
 * 【职业连接：索引与数据库】
 * 这种“在有序集合中寻找最近邻”的操作是数据库 B+ 树索引的核心逻辑。
 * 在深圳的大厂后端面试中，理解这种“哨兵思想”能展示你对边界控制的深度思考：
 * “通过改变数据的组织方式（增加哨兵），来简化代码逻辑，提高系统的健壮性。”
 *
 * 【反思】
 * 1. 迭代器安全：std::prev(it) 是获取前驱节点的安全姿态。
 * 2. 类型转换：在计算差值时强转 long long，是为了防止极端数据下的溢出风险（虽然此题 int 够用）。
 * 3. 优雅代码：哨兵模式让代码行数减少了一半，可读性提升了一个档次。
 */