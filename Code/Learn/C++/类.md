# C++ 类与面向对象基础 (Classes and OOP Foundations)

## 1. 类与对象 (Class vs. Object)
*   **类 (Class)**：一种抽象的用户自定义数据类型（ADT），是对现实世界实体的逻辑建模。它定义了数据（属性）和操作这些数据的函数（行为）。
*   **对象 (Object)**：类的具体实例（Instance），是内存中分配的实体。

## 2. 封装与访问控制 (Encapsulation)
封装是 OOP 的第一大特性，其核心在于**信息隐藏**。通过访问修饰符（Access Modifiers）定义成员的可见性：

*   **`private`（私有）**：默认级别。仅类内部的成员函数可访问。用于保护核心数据。
*   **`public`（公有）**：类外部可访问。通常作为类的接口（Interface）。
*   **`protected`（保护）**：类内部及派生类（子类）可访问。

> **[对比 C Struct]**：在 C++ 中，`struct` 和 `class` 的唯一区别是默认访问权限。`struct` 默认为 `public`，`class` 默认为 `private`。

## 3. 构造函数与析构函数 (Lifecycle Management)

### 3.1 构造函数 (Constructor)
*   **特征**：函数名与类名相同，无返回类型。在对象创建时**自动调用**。
*   **初始化列表 (Initialization List)**：**【高效编程核心】**
    ```cpp
    class Point {
        int x, y;
    public:
        Point(int x_val, int y_val) : x(x_val), y(y_val) {} // 直接初始化，比在函数体内赋值效率更高
    };
    ```

### 3.2 析构函数 (Destructor)
*   **特征**：名称前加 `~`。无参数，无返回类型。在对象生命周期结束（超出作用域或 `delete`）时**自动调用**。
*   **RAII 原则**：Resource Acquisition Is Initialization。在构造时申请资源（内存、文件句柄），在析构时释放。这是 C++ 防止内存泄漏的核心机制。

## 4. `this` 指针
*   **本质**：指向当前对象本身的**隐含常量指针**。
*   **逻辑作用**：在非静态成员函数中，编译器会自动传递 `this` 指针。它常用于区分同名的参数与成员变量：`this->x = x;`。

## 5. 成员函数 (Member Functions)
*   **常成员函数 (const Member Functions)**：
    ```cpp
    int getValue() const; // 承诺不修改类中的任何成员变量
    ```
    在 PS II 的算法实现中，对于只读操作（如获取树的高度），务必标记为 `const` 以增强代码健壮性。

## 6. 静态成员 (Static Members)
*   **`static` 成员变量**：存储在全局数据区，被该类的所有对象**共有**。
*   **`static` 成员函数**：不属于特定对象，没有 `this` 指针，只能访问类的静态成员。

---

### 💡 [NJU PS II 进阶：面向对象思维]

1.  **从“操作”转向“对象”**：
    *   在 C 中，你写 `list_add(&my_list, 10)`，思维是：我对这个数据执行这个操作。
    *   在 C++ 中，你写 `my_list.add(10)`，思维是：这个对象自己执行了增加动作。
2.  **契约意识**：
    `public` 接口是类对外部的**承诺**。只要接口不变，类内部实现的重构（比如把底层数组换成链表）不会影响任何调用方的代码。
3.  **运算符重载 (Operator Overloading)**：
    C++ 允许你给类定义 `+`, `-`, `==`, `<<` 等符号。这在 PS II 处理复杂数学对象（如向量、矩阵）时非常有用。

---

既然你已经掌握了类的基本结构，接下来的两项技术：**继承（Inheritance）** 与 **模板（Templates）**，将带你进入 C++ 最具威力的高级领域。

在南大 **《问题求解 II》** 中，你会频繁接触 **STL（标准模板库）**，而理解模板是使用 STL 的前提；继承则能帮你构建具有层次结构的复杂系统。

---

# C++ 进阶：继承、多态与模板 (Inheritance, Polymorphism and Templates)

## 1. 继承 (Inheritance)
继承允许一个类（派生类）继承另一个类（基类）的属性和行为，实现代码复用与逻辑分类。

### 1.1 基本语法
```cpp
class Base { /* 基类成员 */ };
class Derived : public Base { /* 派生类新增成员 */ };
```
*   **公有继承 (`public`)**：最常用的方式。基类的 `public` 成员在派生类中仍为 `public`。
*   **访问权限扩展**：基类的 `private` 成员对派生类不可见；若希望派生类可见但外部不可访问，应使用 **`protected`**。

### 1.2 构造与析构顺序
*   **构造**：先调用基类构造函数，再调用派生类构造函数。
*   **析构**：先调用派生类析构函数，再调用基类析构函数（与构造顺序相反）。

## 2. 虚函数与多态 (Virtual Functions & Polymorphism)
多态允许“一个接口，多种实现”，是框架设计的核心。

*   **虚函数 (`virtual`)**：在基类中声明，允许派生类重写（Override）。
*   **动态绑定 (Dynamic Binding)**：通过基类指针或引用调用虚函数时，程序会在**运行时**根据对象的实际类型决定调用哪个函数。
*   **虚析构函数**：如果类中包含虚函数，基类的析构函数必须声明为 `virtual`，否则 `delete` 基类指针时可能导致派生类资源无法释放。

## 3. 模板与泛型编程 (Templates)
模板是 C++ **“零开销抽象”** 的体现，允许编写与类型无关的代码。

### 3.1 函数模板 (Function Templates)
```cpp
template <typename T>
T my_max(T a, T b) {
    return (a > b) ? a : b;
}
```
*   **实例化**：编译器根据传入参数的类型（如 `int` 或 `double`），在编译期自动生成对应的代码版本。

### 3.2 类模板 (Class Templates)
这是实现通用数据结构（如 `Stack`, `List`）的核心工具。
```cpp
template <typename T>
class Stack {
private:
    T* elements;
    int top;
public:
    void push(T val);
};
```

---

## 4. C++ 内存管理：`new` 与 `delete`
与 C 语言的 `malloc/free` 相比，C++ 的运算符更智能：
*   **`new`**：分配内存 + **自动调用构造函数**。
*   **`delete`**：**自动调用析构函数** + 释放内存。
*   **数组形式**：`new T[n]` 对应 `delete[] p`。

---

### 💡 [NJU PS II / CSAPP 深度补丁]

1.  **静态多态 vs. 动态多态**：
    *   **模板**是静态多态（编译期决定），运行效率极高（无函数调用开销）。
    *   **虚函数**是动态多态（运行期决定），通过 **虚函数表 (vtable)** 实现。
2.  **STL 的本质**：
    下学期你会用的 `std::vector<T>`、`std::map<K, V>` 全都是基于**类模板**实现的。理解了模板，你就能看懂 STL 源码中复杂的报错信息。
3.  **RAII (资源获取即初始化)**：
    这是 C++ 最伟大的设计模式。将 `malloc` 放在构造函数，`free` 放在析构函数，利用对象的生命周期自动管理内存。这能从根本上杜绝你在 C 语言练习中遇到的内存泄漏问题。
