# 可变数组：抽象数据类型与动态内存管理 (Resizable Array)

## 1. 核心需求与设计动机
*   **痛点**：标准 C 语言数组在定义时必须确定长度，无法根据运行时的需求动态扩展。
*   **设计目标**：构建一个能够“按需增长”的数据结构，并将内存管理的细节隐藏在接口函数之后（封装）。

## 2. 数据结构定义
使用 `struct` 将数据指针与元数据（Metadata）捆绑。
```c
typedef struct {
    int *array;  // 指向堆空间的物理数组
    int size;    // 逻辑上的数组大小
} Array;
```

## 3. 生命周期管理：创建与销毁
### 3.1 构造函数 (`Array_create`)
*   **内存分配**：在堆上分配初始长度的连续空间。
*   **传递方式**：此处采用“值返回”模式，即函数内部构造一个结构体局部变量，返回时将其值拷贝给调用者。

### 3.2 析构函数 (`Array_free`)
*   **资源回收**：必须显式调用 `free()` 释放内部的 `array` 指针所指空间。
*   **防御编程**：释放后将指针置为 `NULL` 并将 `size` 归零，防止产生“野指针”。

## 4. 访问机制与自动增长 (The "At" Logic)
这是可变数组最核心的逻辑，通过一个函数统一处理读取、写入和扩容。

### 4.1 接口语义
`int *Array_at(Array *a, int index)`：
*   **返回值**：返回的是一个**指针**。
*   **优势**：利用指针的特性，该接口既可以作为**左值**（写入：`*Array_at(&a, 0) = 10;`），也可以作为**右值**（读取：`int x = *Array_at(&a, 0);`）。

### 4.2 自动扩容策略 (`Array_inflate`)
当访问越界（`index >= size`）时，触发扩容逻辑：
1.  **新领地申请**：`malloc` 一块更大的空间。
2.  **数据迁移**：使用循环将旧数组内容拷贝至新数组。
3.  **遗迹清理**：`free` 掉旧数组指针。
4.  **状态更新**：重定向 `a->array` 指向新空间，并更新 `size`。

---

## 💡 [NJU ICS/PA 深度补丁]

### 1. 扩容策略的效率问题 (Amortized Analysis)
*   **当前策略**：翁恺老师演示的代码使用的是“固定块大小（`BLOCK_SIZE`）”增长。
*   **缺陷**：在数据量极大时，频繁触发 `malloc` 和 `copy` 会导致性能下降。
*   **工业级做法**：通常采用**倍增策略**（如每次扩容为原来的 2 倍）。这样可以保证 $n$ 次插入操作的摊还时间复杂度为 $O(1)$。

### 2. `realloc` 函数的平替
*   在 C 语言标准库中，`realloc(ptr, new_size)` 可以直接完成扩容逻辑（如果后面有空位就地扩，没空位就找新地方搬运并自动 `free` 旧指针）。
*   **注意**：在 ICS/PA 实验中，理解手动搬运的逻辑比直接用 `realloc` 更能帮你建立系统直觉。

### 3. 封装的意义
*   通过 `Array_size(const Array *a)` 获取大小，而不是直接读 `a->size`。
*   **好处**：这在 C 语言中模拟了“私有变量”的概念。如果未来数组结构的定义变了，只要接口函数（API）不变，调用者的代码就不需要修改。

---

## 🚀 寒假自学建议：动手实验

1.  **性能观测**：尝试在循环里插入 100 万个数据，分别测试 `BLOCK_SIZE = 20` 和 `BLOCK_SIZE = 2000` 的运行速度差异。
2.  **类型通用化**：尝试把 `int *array` 改成 `double *array` 或者是你之前定义的 `Student *array`。你会发现 C 语言在处理通用类型时的无力感，这会帮你理解为什么 C++ 之后要引入 **Template（模板）**。
