# 字符串 (Strings) —— 字符数组与内存协议

## 1. 定义与本质
*   **内存协议**：以整数 `0`（即字符 `'\0'`）结尾的一串字符。
*   **区分三个“0”**：
    *   `0`：数字 0，等价于 `'\0'`（ASCII 码为 0）。
    *   `'0'`：字符 0，其 ASCII 码为 48。
*   **计算开销**：`0` 是标志位，不计入字符串有效长度，但占用 1 字节存储空间。

## 2. 字符串变量：内存位置的差异（核心）

### 2.1 指针形式（指向常量区）
`char *str = "Hello";`

*   **存储位置**：字符串常量 `"Hello"` 存储在程序的 **只读数据区（Read-only Data/Text Segment）**。
*   **行为特征**：`str` 仅是一个指针，指向该区域的首地址。
*   **致命陷阱**：试图修改其内容（如 `str[0] = 'B';`）会导致 **段错误（Segmentation Fault）**，因为该内存空间受硬件保护。

### 2.2 数组形式（指向栈区）
`char word[] = "Hello";`
*   **存储位置**：编译器在 **栈（Stack）** 或数据区分配空间，并将常量区的 `"Hello"` **拷贝**一份到该空间。
*   **行为特征**：`word` 是一个字符数组，拥有独立的物理空间，**内容可修改**。

> **[NJU ICS 进阶] 编译器视角**：
>
> *   **构造**字符串（需要修改、拼接）——》使用 **数组**。
> *   **处理**字符串（作为参数传递、只读匹配）——》 使用 **指针**。

## 3. 字符串的输入输出与安全

### 3.1 `scanf` 的行为
*   **终止符**：遇到空格、Tab、回车即停止读入。这意味着 `scanf` 无法直接读入带空格的句子。
*   **溢出风险**：默认的 `%s` 不检查边界。如果输入长度超过数组定义，会发生 **缓冲区溢出（Buffer Overflow）**，这是计算机安全史上最著名的漏洞来源。

### 3.2 防御性编程
*   **限长输入**：`char buf[8]; scanf("%7s", buf);` 永远预留 1 字节给 `\0`。
*   **空串陷阱**：
    *   `char buf[100] = "";  buf[0]` 为 `\0`，剩余 99 字节可用。
    *   `char buf[] = "";`  编译器仅分配 1 字节，逻辑上此数组已“满”，无法追加内容。

## 4. 字符串数组 (Array of Strings)

*   **二维数组模式**：`char a[3][10];` 
    *   内存中是连续的矩形块，每行固定 10 字节。会产生内部碎片（浪费空间）。
*   **指针数组模式**：`char *a[3];`
    *   每个元素是一个指针。常用于 `main(int argc, char *argv[])`。
    *   **内存视图**：指针指向的地方长度可以互不相同，更加灵活。

## 5. 标准库函数 `string.h` 的底层逻辑
*   **`strlen(s)`**：返回s的字符串长度，不包含结尾的0

    *   逻辑：从 `s` 开始计数，直到遇到 `0`。
    *   注意：返回类型通常是 `size_t`（无符号长整型）。

*   **`strcmp(s1, s2)`**：返回值为`int`

    *   逻辑：逐字符比较 ASCII 码。
    *   返回：`0` 表示相等；`>0` 表示 `s1 > s2`；`<0` 表示 `s1 < s2`。

*   **`strcpy(dst, src)`**：会返回`dst` 

    * 逻辑：将 `src`（含 `\0`）拷贝到 `dst`。

    * **危险**：若 `dst` 空间不足，会覆盖后续内存数据。

    * 应用：复制一个字符串

      ```c
      char *dst = (char*)malloc(strlen(src)+1);
      strcpy(dst,scr);
      ```

## 6.单字符输入输出

* `putchar`
  * `int putchar(int c)`
  * 向标准输出写一个字符
  * 返回写了几个字符，EOF（-1）表示写失败
* `getchar`
  * `int getchar(void);`
  * 从标准输入读入一个字符
  * 返回类型是`int`是为了返回EOF（-1）
  * Windows——》Ctrl-Z

学弟，你对这两个函数的关注点非常到位。在 C 语言中，`strchr` 和 `strrchr` 是处理文本解析（Parsing）最常用的“轻量级武器”。

如果说 `strcmp` 是为了“判断”，那么这两个函数就是为了“定位”。在下学期的 PA 实验里，当你需要解析一条指令（比如 `mov %eax, %ebx`）里的逗号或空格时，它们就是你的首选。

---

## 7.字符串定位函数：`strchr` 与 `strrchr`

### 1. 函数原型与定义

这两个函数都包含在 `<string.h>` 头文件中。

*   **`strchr` (String Character)**: 查找字符串中**第一次**出现某个字符的位置。
    ```c
    char *strchr(const char *s, int c);
    ```
*   **`strrchr` (String Reverse Character)**: 查找字符串中**最后一次**（从右侧开始找）出现某个字符的位置。
    ```c
    char *strrchr(const char *s, int c);
    ```

#### 核心要点：
1.  **返回类型**：它们返回的是一个**指针**，指向找到的那个字符在内存中的地址。如果没找到，返回 `NULL`。
2.  **搜索范围**：搜索包括字符串末尾的 `\0`。如果 `c` 是 `0`，函数会返回指向 `\0` 的指针。
3.  **参数类型**：尽管 `c` 是 `int` 型，但在比较时它会被转换回 `char`。

---

### 2. 代码实例：定位与提取

#### 示例 A：使用 `strchr` 拆分键值对
假设你有一个配置文件，里面有一行 `"IP:192.168.1.1"`，你想提取冒号后面的内容。

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    const char *line = "IP:192.168.1.1";
    char *p = strchr(line, ':'); // 寻找第一次出现的冒号

    if (p != NULL) {
        // p 指向 ':'，那么 p+1 就是冒号后面的内容
        printf("Found separator at index: %ld\n", p - line); // 指针相减得到下标
        printf("The IP address is: %s\n", p + 1);
    }
    return 0;
}
```

#### 示例 B：使用 `strrchr` 提取文件后缀
如果你有一个长路径 `"/home/user/test.tar.gz"`，你想得到最后一个点之后的部分。

```c
#include <stdio.h>
#include <string.h>

int main(void) {
    const char *path = "/home/user/test.tar.gz";
    char *p = strrchr(path, '.'); // 寻找最后一次出现的点

    if (p != NULL) {
        printf("The extension is: %s\n", p + 1); // 输出 gz
    }
    return 0;
}
```

---

### 3. 深度对比：一前一后

| 特性         | `strchr`               | `strrchr`                      |
| :----------- | :--------------------- | :----------------------------- |
| **搜索方向** | 从左向右（正向）       | 从右向左（反向）               |
| **定位点**   | 第一次出现的位置       | 最后一次出现的位置             |
| **典型应用** | 查找分隔符、解析协议头 | 获取扩展名、获取路径中的文件名 |

---

### 4. 极客进阶：手动实现（NJU 训练法）

为了训练你的“底层直觉”，我们不调用库函数，手动用指针实现它们。

#### 手动实现 `mystrchr`：
```c
char *mystrchr(const char *s, int c) {
    while (*s != (char)c) {
        if (*s == '\0') {
            return NULL;
        }
        s++;
    }
    return (char *)s; // 强制转换去掉 const 属性
}
```

#### 手动实现 `mystrrchr`（巧妙逻辑）：
这里有一个技巧：我们正向遍历，每当遇到目标字符，就更新一个“最后位置”的记录员。
```c
char *mystrrchr(const char *s, int c) {
    char *last = NULL;
    do {
        if (*s == (char)c) {
            last = (char *)s; // 记录最新发现的位置
        }
    } while (*s++); // 遍历直到结束
    return last;
}
```

---

### 5. 常见应用场景总结

1.  **路径解析**：
    *   用 `strrchr(path, '/')` 找到最后一个斜杠，其后的内容就是**文件名**。
2.  **参数提取**：
    *   在 URL（如 `index.html?user=admin`）中，用 `strchr(url, '?')` 定位**参数起始点**。
3.  **敏感词过滤/非法字符检查**：
    *   检查用户名是否包含空格：`if (strchr(username, ' ')) { ... }`。
4.  **内存截断（慎用）**：
    *   有时候我们会通过 `*p = '\0'` 手动在某个字符处把字符串“砍断”，从而提取前半部分。

