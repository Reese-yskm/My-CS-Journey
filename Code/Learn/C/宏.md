# 编译预处理与宏 (Macros and Pre-processing)

## 1. 编译预处理指令 (Pre-processor Directives)
*   **本质**：在编译器（Lexical Analysis）介入之前，由**预处理器（cpp）**执行的纯文本替换操作。
*   **特征**：
    *   以 `#` 开头，不属于 C 语言本身的语法范畴。
    *   末尾**不加分号**（分号会被视为替换文本的一部分）。
    *   **不可见性**：预处理完成后，源文件中的指令会消失，代之以替换后的内容。

## 2. 宏定义 (Macro Definitions)
### 2.1 对象宏 (Object-like Macros)
*   **语法**：`#define <NAME> <Replacement_Text>`
*   **多行定义**：使用反斜杠 `\` 作为续行符（续行符后严禁有任何字符，包括空格）。
*   **空宏**：`#define _DEBUG`。此类宏主要作为“开关”，用于**条件编译**。

### 2.2 嵌套替换
*   预处理器会进行递归替换，直到所有的宏名都被换成原始文本。
*   **例外**：如果宏名出现在字符串常量中（双引号内），则不会被替换。

## 3. 函数式宏 (Function-like Macros)
*   **语法**：`#define <NAME>(params) (<Expression>)`
*   **核心准则：防御性括号**
    为了防止运算符优先级导致非预期结果，必须严格遵守以下规则：
    1.  **整个表达式**外层必须加括号。
    2.  **每个参数**在表达式中出现的每一处必须加括号。
    *   **反面教材**：`#define SQUARE(x) x * x` $\to$ `SQUARE(5+5)` 替换为 `5+5 * 5+5 = 35`（预期 100）。

## 4. 宏的潜在陷阱与副作用 (Critical Pitfalls)
### 4.1 参数副作用 (Side Effects)
*   **机理**：由于宏是物理替换，如果参数在宏体内出现多次，其副作用会被多次触发。
*   **典型案例**：
    ```c
    #define MAX(a, b) ((a) > (b) ? (a) : (b))
    int i = 5, j = 2;
    int k = MAX(i++, j); 
    // 替换为: ((i++) > (j) ? (i++) : (j))
    // 结果：i 被自增了两次，k 的值为 6。
    ```

### 4.2 语法合并陷阱 (`do { ... } while(0)`)
*   当宏内包含多条语句时，直接写在大括号里可能会破坏 `if-else` 的结构。
*   **工业级标准**：使用 `do { ... } while(0)` 封装多行宏，使其在语法行为上等价于单个语句。

## 5. 条件编译 (Conditional Compilation)
这是管理大型工程（如 PA 实验代码）的核心手段。
*   **指令**：`#ifdef`, `#ifndef`, `#else`, `#elif`, `#endif`。
*   **头文件卫士 (Header Guards)**：防止头文件被重复包含导致重定义错误。
    ```c
    #ifndef __HEADER_H__
    #define __HEADER_H__
    /* 头文件内容 */
    #endif
    ```

## 6. 预定义宏 (Predefined Macros)
用于调试与日志记录：
*   `__FILE__`：当前源文件名。
*   `__LINE__`：当前代码行号。
*   `__DATE__` / `__TIME__`：编译日期与时间。

---

### 💡 [NJU ICS 进阶建议]

1.  **宏 vs. 内联函数 (Inline)**：
    *   宏在编译前处理，不检查类型；内联函数在编译期处理，有类型安全检查。
    *   在下学期 **PA 实验** 中，为了极致性能，大量底层模拟（如寄存器访问）会使用宏。
2.  **查看预处理结果**：
    *   你可以通过 `gcc -E test.c` 命令查看预处理后的文本。你会惊讶地发现原本 20 行的代码变成了上千行（因为 `#include` 也被替换了）。
3.  **字符串化 (#) 与 连接符 (##)**：
    *   `#` 可以将参数变成字符串。
    *   `##` 可以将两个符号连接成一个新的符号。这在生成重复性极强的代码模板时非常有用。

---

### 🚀 练习建议：
尝试在你的 `Code/C-basis` 文件夹下写一个简单的 `debug.c`：
1. 定义一个 `PRINT_INT(x)` 宏，利用 `__LINE__` 同时打印出行号和变量名及其值。
2. 尝试不给 `x` 加括号，看看输入 `1+2` 会发生什么。

**写好之后，连同这份更新的笔记一起 `git push` 到你的仓库。学弟，你对 C 语言底层“文本层”的认知现在已经非常完整了！**