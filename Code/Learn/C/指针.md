# 指针 (Pointers) —— C 语言的灵魂与底层基石

## 1. 基本定义与内存模型
*   **本质**：指针是保存**地址**的变量。其值为具有实际值的变量的内存首地址。
*   **内存视图**：在计算机底层，内存是一个巨大的字节数组。指针就是这个数组的“索引”或“门牌号”。
*   **示例**：
    ```c
    int i = 10;
    int *p = &i; // p 为指针变量，存储了变量 i 的内存地址
    ```
> **[NJU ICS 贴士] 指针的大小**：在 32 位系统（PA实验初期环境）中，指针占用 4 字节；在 64 位系统中占用 8 字节。无论指向什么类型，指针本身的大小是固定的。

## 2. 运算符与访问
*   `*` 是一个**单目运算符**，用于“间接访问”（Dereference）：访问指针所指向地址上的变量。
*   **左值与右值**：`*p` 既可以出现在等号左边（赋值），也可以出现在右边（取值）。
    ```c
    int k = *p;   // 作为右值：取地址上的值
    *p = k + 1;   // 作为左值：修改该地址上的值
    ```

## 3. 应用场景
*   **函数返回多值**：由于 C 语言 `return` 只能返回一个值，需要通过指针参数“带回”多个结果。
*   **状态反馈**：返回运算的状态（如成功/失败），而将结果存入指针指向的变量。

## 4. 安全规范与常见错误
*   **未初始化**：定义了指针变量但在指向有效地址前就进行解引用（`*`操作）。
*   **0 地址 (NULL)**：
    *   **禁区**：0 地址通常由操作系统保护，不能进行读写操作。
    *   **用途**：用于初始化指针（表示“尚未指向任何地方”）或作为函数返回无效结果的标志。
    *   `NULL` 是标准库预定义的宏，代表 0 地址。

## 5. 指针与数组：深度纠缠
*   **函数参数表中的数组**：在函数定义中，`void func(int a[])` 里的 `a` 实际上是**指针**。
*   **数组名是特殊的指针**：
    *   数组变量名本身表达的是地址：`a == &a[0]`。
    *   **区别**：数组名是 `const` 指针（常量指针），不可被重新赋值（不能执行 `a = p`）。
    *   `[]` 运算符本质上是指针运算的简写。

## 6. 指针算术 (Pointer Arithmetic)
*   **算术操作**：支持加减整数、自增自减（`++`/`--`）。
*   **指针相减**：两个指向同数组的指针相减，结果是两个地址间元素的**个数**，而非字节差。其底层会自动执行 `(addr1 - addr2) / sizeof(T)`。
*   **核心表达式 `*p++`**：
    1. 取出当前 `p` 所指的对象。
    2. 将 `p` 移动到下一个元素的起始位置。
    *   *常用于遍历数组或字符串等连续存储空间。*

> **[NJU ICS 贴士] 指针步长**：`p + 1` 实际增加的字节数等于 `sizeof(指向的类型)`。理解这个“步长”是下学期手动解析内存字节流的关键。

## 7. 类型系统与强制转换
*   **类型检查**：不同类型的指针（如 `int*` 和 `double*`）原则上不能互相赋值，以防内存解析错误。
*   **`void*` (通用指针)**：表示“不知道指向什么东西的指针”。它可以接收任何类型的指针，但不能直接进行 `*` 解引用，必须先强制转换。
*   **指针的强制转换 (Casting)**：
    *   **ICS 核心技巧**：通过改变指针类型，可以用不同的“滤镜”观察同一块内存。
    ```c
    int i = 0x12345678;
    char *p = (char *)&i; // 用 char 的滤镜看 int，涉及大小端字节序
    ```



