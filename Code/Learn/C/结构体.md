# 结构体



## 结构体初始化 

* 声明结构类型

```c
struct date
{
	int month;
    int day;
    int year;
};
int main(void)
{
    
    struct date today;
    today.month = 07;
    today.day = 31;
    today.year = 2014;
    
    printf("Today's date is %i-%i-%i.\n",today.year,today.month,today.day);
    return 0;
}
```

```c
struct
{
    int x;
    int y;
}p1,p2
//p1,p2都是一种无名结构，里面有x和y
```

```c
struct point
{
    int x;
    int y;
}p1,p2
//p1,p2都是一种point，里面有x和y
```

* 结构的初始化

```c
struct date today = {07,31,2014};
struct date today = {.month=7, .year=2014};//day未初始化，为0
```

* 结构指针
  * 和数组不同，结构变量的名字并不是结构变量的地址，必须使用&运算符
  * `struct date *pDate = &today;`



# 结构体与函数 

## 1. 结构体作为函数参数：传值调用 
在 C 语言中，结构体变量在函数传递时的行为与基础类型（如 `int`）完全一致：**传递的是值的副本**。

*   **克隆机制**：调用函数时，会在函数内部新建一个结构体变量，并完整地复制调用者结构体中的所有成员。
*   **局限性**：
    1.  **修改无效**：在函数内对结构体成员的修改仅作用于副本，不会影响原变量。
    2.  **性能开销**：若结构体规模庞大（包含大型数组），全量拷贝会严重消耗 CPU 时间与栈空间。

## 2. 结构体作为返回值
C 语言允许函数直接返回整个结构体。
*   **应用场景**：常用于构造并初始化一个新的结构体。
*   **底层逻辑**：返回时同样涉及一次完整的结构体值拷贝。

## 3. 结构体指针：高效处理方案
为了规避传值调用的副作用，系统编程中通常传递**结构体指针**。

### 3.1 定义与初始化
```c
struct date myday;
struct date *p = &myday; // p 指向结构体变量 myday 的内存首地址
```

### 3.2 成员访问运算符 `->`
由于指针存的是地址而非值，访问成员时需要先解引用：
*   **标准写法**：`(*p).month = 12;` （注意：`.` 的优先级高于 `*`，故必须加括号）
*   **语法糖（推荐写法）**：`p->month = 12;`
    *   **含义**：`->` 表示访问指针所指的结构体变量中的成员。

## 4. 结构体输入：解决“无法直接 `scanf`”
由于结构体是复合类型，`scanf` 无法一次性读入整个结构。

*   **解决方案 A：传址读入（最地道）**
    ```c
    void getStruct(struct point *p) {
        scanf("%d", &p->x); // 读入到指针所指结构体的成员 x 中
        scanf("%d", &p->y);
    }
    // 调用：getStruct(&y);
    ```
*   **解决方案 B：构造并返回**
    ```c
    struct point getStruct() {
        struct point temp;
        scanf("%d %d", &temp.x, &temp.y);
        return temp;
    }
    // 调用：y = getStruct();
    ```

---

### 💡 [NJU ICS/PA 进阶补丁]

1.  **指针传递的本质**：当你传递结构体指针（如 `struct date *`）时，无论结构体本身有多大，函数参数只占用 **4 字节或 8 字节**（取决于系统位数）。这种 O(1) 的开销是大型工程的基石。
2.  **运算符优先级陷阱**：
    *   `p->month++` 增加的是 `month` 成员的值。
    *   `p++->month` 则是先访问成员，然后将指针 `p` 移动到下一个结构体的位置（数组遍历）。
3.  **内存对齐 (Alignment)**：
    虽然在笔记中感觉成员是紧挨着的，但在底层（ICS 会深挖），编译器为了提高 CPU 访问效率，会在成员之间插入一些“填充字节（Padding）”。所以 `sizeof(struct)` 往往大于成员大小之和。

---

## 枚举类型 (Enumerations)

### 1. 定义与基本语法
枚举是一种用户自定义的数据类型，用于声明一组命名的**整型常量**。它通过语义化的标签替代裸露的数字，提高代码的可读性与维护性。

*   **声明语法**：
    ```c
    enum COLOR { RED, YELLOW, GREEN };
    ```
*   **变量声明**：
    ```c
    enum COLOR myColor = RED;
    ```

### 2. 枚举值的底层逻辑
在编译器内部，枚举成员被视为 `int` 类型。
*   **自动赋值**：默认从 `0` 开始递增（如上例中 `RED=0, YELLOW=1, GREEN=2`）。
*   **显式赋值**：可以手动指定某个成员的值，后续成员在此基础上继续自增。
    ```c
    enum STATUS {
        SUCCESS = 0,
        ERROR_NOT_FOUND = 404,
        ERROR_SERVER = 500,
        UNKNOWN // 自动变为 501
    };
    ```

### 3. 枚举 vs 宏定义 (`#define`)
虽然两者都能定义常量，但枚举在系统级编程中具有不可替代的优势：
1.  **调试可见性 (GDB Support)**：
    *   使用 `#define` 定义的宏在预处理阶段被替换，**GDB 调试器无法识别宏名**（只能看到数字）。
    *   枚举变量在调试中可以直接显示其符号名称（如显示 `RED` 而非 `0`），这对于复杂状态机的调试至关重要。
2.  **作用域限制**：枚举遵循 C 语言的作用域规则，而宏是全局替换，容易引发命名空间冲突。
3.  **逻辑分组**：枚举强行将相关的常量归类为一种类型，符合程序设计的“高内聚”原则。

### 4. 工程实践与技巧
*   **结合 `typedef` 使用**：
    为了简化书写（省去 `enum` 关键字），工业界常采用如下写法：
    ```c
    typedef enum {
        SYS_IDLE,
        SYS_RUNNING,
        SYS_HALT
    } SystemState;
    
    SystemState current_state = SYS_IDLE;
    ```
*   **匿名枚举**：
    若仅需要一组局部常量且不需要声明对应的变量类型，可以使用匿名枚举：
    ```c
    enum { MAX_RETRY = 3, TIMEOUT_MS = 1000 };
    ```

### 5. 典型应用场景：有限状态机 (FSM)
在底层开发（如南大 PA 实验中的 CPU 模拟）中，枚举是描述系统状态的最佳工具：
```c
enum { NEMU_RUNNING, NEMU_STOP, NEMU_END, NEMU_ABORT };
// 用于记录模拟器的当前运行状态，便于在不同的控制流中做出逻辑判断
```

---

### 💡 极客感悟（存入 GitHub README）
> “枚举是 C 语言中‘防御性编程’的体现。它通过将魔术数字（Magic Numbers）抽象为符号，在不增加运行时开销的前提下，利用编译器的符号表为开发者提供更好的开发体验。”



学弟，结构体这一章最后的两个部分——**联合体（Union）**和**内存对齐（Alignment）**，是 C 语言中“性价比最高”的知识。

在普通的开发中它们可能不常用，但在**南大 ICS（计算机系统基础）的 PA 实验**中，它们是实现“通用寄存器模拟”和“高效数据解析”的**核心核武器**。

以下是为你整理的结构体进阶笔记，旨在帮你打通从“语法”到“硬件模拟”的最后一公里。

---

## 联合体 (Union) 与 内存布局进阶

### 1. 联合体 (Union) —— 同一物理空间的多种解读
联合体与结构体非常相似，但其成员**共用同一块物理内存**。

*   **定义语法**：
    ```c
    union Data {
        int i;
        char ch;
        float f;
    };
    ```
*   **空间占用**：联合体的大小等于其**最大成员的大小**（上例中为 4 字节）。
*   **核心特性**：给一个成员赋值，会覆盖其他成员的值。
*   **本质逻辑**：它是 C 语言提供的一种**“内存视图切换”**工具。

> #### 🚀 [NJU ICS/PA 核心应用：寄存器模拟]
> 在 PA 实验中，你需要模拟 80386 的寄存器。比如 `EAX` (32位)、`AX` (16位)、`AL` (8位) 其实在物理上是同一个地方。利用 `union` 可以实现完美的模拟：
> ```c
> union {
>  uint32_t eax;
>  struct {
>      uint16_t low_16;
>      uint16_t high_16;
>  };
>  struct {
>      uint8_t al, ah, bl, bh; // 这种嵌套可以精准切分字节
>  };
> } gpr;
> ```

---

### 2. 内存对齐 (Memory Alignment) —— 硬件效率的妥协
如果你定义了一个 `struct`，包含一个 `char` 和一个 `int`，你可能认为它占 5 字节，但实际上 `sizeof` 会告诉你它占 **8 字节**。

*   **对齐规则**：为了提高 CPU 读取内存的速度，编译器会在成员之间插入一些空白字节（称为 **Padding**，填充）。
*   **基本原则**：
    1.  每个成员的偏移量必须是其自身大小的整数倍。
    2.  结构体的总大小必须是其最大成员大小的整数倍。
*   **示例分析**：
    
* 在定义结构体时，应按成员大小降序排列

    *   这样做可以最大程度的减少编译器自动插入的填充空间，压缩结构体体积
    *   在大规模处理数据时，可以节省内存并提高缓存命中率

    ```c
    struct S {
        char a;     // 偏移量 0
        // 这里会填充 3 个字节
        int b;      // 偏移量 4 (必须是 4 的倍数)
    }; // 总大小 8
    ```

> #### 💡 [NJU ICS 进阶：缓存一致性]
> 为什么硬件要求对齐？因为现代 CPU 读取内存不是按字节读的，而是按“块（Cache Line）”读的。如果一个数据跨越了两个块，CPU 就需要读两次并进行拼接，效率减半。

---

### 3. 类型定义工具：`typedef`
为了提高代码的可移植性和简洁性，系统编程中几乎所有的结构体都会配合 `typedef` 使用。

*   **标准写法**：
    
    ```c
    typedef struct Node {
        int data;
        struct Node *next; // 注意：指向自身的指针不能省略原来的 struct 关键字
    } Node;
    ```
*   **意义**：将 `struct Node` 抽象为一个全新的类型名 `Node`，使代码更接近面向对象语言。

---

### 4. 结构体嵌套 (Nested Structs)
结构体内部可以包含另一个结构体作为成员。
*   **逻辑**：这实现了数据的“层级化管理”。
*   **访问**：使用连续的点运算符 `a.b.c` 或 `p->b.c`。

---

## 🏆 结构体章节总结感悟

你在整理 GitHub README 时，可以加上这段关于“数据抽象”的理解：

> **“结构体（Struct）是 C 语言中‘空间维度’的抽象，它将离散的数据聚合为实体；而联合体（Union）是‘逻辑维度’的抽象，它允许我们以不同的精度（字节、半字、字）去观察同一份内存。理解了内存对齐，才算真正理解了高级语言与底层硬件之间的那层默契。”**

---

### 🚀 寒假自学建议：动手实验

既然你已经配好了环境，尝试运行这段“测谎仪”代码，观察输出结果：

```c
#include <stdio.h>

typedef struct {
    char a;
    int b;
    char c;
} Test;

int main() {
    Test t;
    printf("Size of struct: %zu\n", sizeof(Test));
    printf("Address a: %p\n", &t.a);
    printf("Address b: %p\n", &t.b);
    printf("Address c: %p\n", &t.c);
    return 0;
}
```
**挑战问答**：
1. `sizeof(Test)` 是多少？（提示：不是 6）
2. 如果把 `int b` 挪到最后面，大小会变吗？

