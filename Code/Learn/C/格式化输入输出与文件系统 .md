# 格式化输入输出与文件系统 (Formatted I/O and File Systems)

## 1. 格式化输入输出 (Formatted I/O)
格式化 I/O 本质上是 C 语言提供的一种基于格式控制字符串的**类型转换机制**。

### 1.1 `printf`：格式化输出
*   **语法结构**：`%[flags][width][.precision][length]specifier`
*   **核心参数解析**：
    *   `flags`：`-` 左对齐；`+` 强制显示正负号；`0` 空位补零。
    *   `width`：最小字符宽度。
    *   `.precision`：浮点数小数位数或字符串最大长度。
    *   `length`：数据长度修饰符（如 `l` 表示 `long`，`ll` 表示 `long long`，`z` 表示 `size_t`）。
*   **返回值**：成功写入的字符总数。

### 1.2 `scanf`：格式化输入
*   **机制**：根据格式字符串从输入流中提取匹配的数据项。
*   **返回值（关键点）**：成功读入并赋值的数据项个数。
    *   *NJU 实践*：必须始终检查 `scanf` 的返回值以确保输入的健壮性。若返回值小于预期，说明发生了类型不匹配或文件结束。
*   **陷阱**：`scanf` 在读入字符串时不会检查目标缓冲区大小（容易导致 Buffer Overflow），且会以空白字符（空格/换行/Tab）作为终止符。

---

## 2. 文件输入输出 (File I/O)
C 语言通过“流（Stream）”来抽象所有外部设备。文件操作是通过 `FILE` 结构体指针进行管理的。

### 2.1 核心操作函数
*   **打开与关闭**：
    *   `fopen(path, mode)`：建立流。常用模式包括 `"r"` (读), `"w"` (写/覆盖), `"a"` (追加)。
    *   `fclose(fp)`：关闭流，刷新缓冲区。**漏掉此步可能导致数据丢失**。
*   **文本流操作**：
    *   `fprintf(fp, ...)` / `fscanf(fp, ...)`：对文件进行格式化读写。
    *   `fgets(buf, size, fp)`：比 `gets` 更安全的行读入函数，限制了读入字符数。

### 2.2 标准流
每个 C 程序启动时会自动打开三个标准流：
1.  `stdin` (Standard Input)
2.  `stdout` (Standard Output)
3.  `stderr` (Standard Error)：专门用于输出错误信息，通常不带缓冲区，确保报错能立即显示。

---

## 3. 二进制文件 (Binary Files)
二进制文件操作是**直接对内存数据的物理镜像进行读写**，不进行任何字符转换。

### 3.1 核心函数：`fread` 与 `fwrite`
*   **原型**：`size_t fread(void *ptr, size_t size, size_t nmemb, FILE *stream);`
*   **特点**：
    *   直接将内存中的字节块（`size * nmemb` 字节）写入磁盘或读入内存。
    *   **效率**：远高于文本 I/O，因为省略了数值转字符串的 CPU 开销。
    *   **结构体处理**：可以直接读写整个 `struct`，但需注意跨平台的**端序（Endianness）**和**结构体对齐（Alignment）**问题。

### 3.2 文件定位（随机访问）
*   **`fseek(fp, offset, whence)`**：移动文件位置指针。
    *   `SEEK_SET`：文件头；`SEEK_CUR`：当前位置；`SEEK_END`：文件尾。
*   **`ftell(fp)`**：返回当前位置指针相对于文件头的字节偏移量。
    *   *常用技巧*：通过 `fseek(fp, 0, SEEK_END)` 后接 `ftell(fp)` 可计算文件总大小。
*   **`rewind(fp)`**：将指针重置回文件头。

---

### 💡 [NJU ICS/PA 进阶建议]

1.  **文本 vs. 二进制的本质区别**：
    *   在 Windows 平台上，文本模式会处理 `\n` $\leftrightarrow$ `\r\n` 的转换，而二进制模式（带有 `b` 后缀，如 `"rb"`）保持原始字节不变。
    *   在 **PA 实验** 中加载模拟器镜像时，必须使用 **二进制模式**，否则程序指令中的某些特定数值可能会被误认为换行符而导致解析错误。
2.  **缓冲区（Buffering）**：
    *   I/O 操作极其昂贵。`FILE` 内部维护了缓冲区，通常在缓冲区满或调用 `fflush` / `fclose` 时才进行物理写入。理解这一点对于编写高性能系统程序至关重要。
3.  **内存 dump 思维**：
    *   二进制读写本质上是内存状态的持久化。你在 `fwrite` 时，其实是在告诉计算机：“把这块内存的 01 状态原封不动地搬到硬盘上”。

**学弟，这一章的内容比较考查细节。建议你下午去敲一个“读入一个二进制文件，并在屏幕上以十六进制格式打印出来”的小工具（类似 Linux 下的 `hexdump`），这能让你瞬间明白二进制读写和 `%x` 格式化的精髓。**



这个程序的功能是：**创建一个学生信息系统，将数据以二进制格式存入硬盘，然后再像“黑客”一样读取它的原始内存字节流（Hex Dump）**。

---

### 实战程序：二进制数据存储与内存镜像查看器

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// 1. 定义一个结构体（回顾之前的结构体知识）
typedef struct {
    int id;
    char name[20];
    double score;
} Student;

// 函数声明：以十六进制格式打印文件内容（像底层程序员一样观察数据）
void hexDump(const char *filename);

int main(void) {
    const char *filename = "student.data";

    // --- 第一部分：格式化输入与二进制写入 ---
    Student s1 = {1001, "Alice", 95.5};
    
    // 以 "wb" (write binary) 模式打开文件
    FILE *fp = fopen(filename, "wb");
    if (fp == NULL) {
        perror("无法打开文件进行写入");
        return 1;
    }

    // 使用 fwrite 直接将内存中的结构体“镜像”写入硬盘
    // 参数：数据指针，单个大小，个数，文件流
    fwrite(&s1, sizeof(Student), 1, fp);
    fclose(fp);
    printf("成功将学生数据写入二进制文件: %s\n\n", filename);


    // --- 第二部分：文件定位与二进制读取 ---
    FILE *fp_read = fopen(filename, "rb");
    if (fp_read == NULL) return 1;

    // 演示 fseek 和 ftell：测量文件大小
    fseek(fp_read, 0, SEEK_END);      // 移动到文件末尾
    long fileSize = ftell(fp_read);  // 获取当前位置（即总长度）
    printf("该二进制文件的总字节数: %ld 字节\n", fileSize);
    rewind(fp_read);                 // 回到文件头准备读取

    Student s2;
    // 使用 fread 将字节流还原回结构体变量
    if (fread(&s2, sizeof(Student), 1, fp_read) == 1) {
        // 使用格式化输出显示结果
        // %.1f 控制小数点，%-10s 控制左对齐
        printf("读取到的数据: ID=%d, Name=%-10s, Score=%.1f\n", s2.id, s2.name, s2.score);
    }
    fclose(fp_read);


    // --- 第三部分：底层视角 (Hex Dump) ---
    printf("\n--- 该文件的底层十六进制镜像 (Hex Dump) ---\n");
    hexDump(filename);

    return 0;
}

// 模拟 Linux 下的 hexdump 工具逻辑
void hexDump(const char *filename) {
    FILE *fp = fopen(filename, "rb");
    unsigned char byte;
    int count = 0;

    // 逐字节读取
    while (fread(&byte, 1, 1, fp) == 1) {
        // 格式化输出：以十六进制打印字节，占2位，不足补0
        printf("%02X ", byte);
        count++;
        if (count % 8 == 0) printf(" "); // 每8位空一格
        if (count % 16 == 0) printf("\n"); // 每16位换行
    }
    printf("\n");
    fclose(fp);
}
```

---

### 🔍 深度解析：你学到了什么？

#### 1. 为什么 `hexDump` 出来的东西长得奇形怪状？
当你运行这个程序，你会看到类似 `E9 03 00 00 41 6C 69 63 65 ...` 这样的输出。
*   **Aha! 瞬间**：`41 6C 69 63 65` 其实就是字母 `Alice` 的 ASCII 码。
*   **端序（Endianness）预警**：你会发现 ID 为 `1001`（十六进制是 `0x03E9`），在内存里显示的却是 `E9 03 00 00`。这就是南大 ICS 必考的 **小端序 (Little-endian)**：低位字节存在低地址。

#### 2. `fwrite` 与 `printf` 的本质区别
*   `printf` 把数字 `1001` 变成了字符 `'1' '0' '0' '1'`（占用 4 个 ASCII 字节）。
*   `fwrite` 直接把 `1001` 在内存里的 4 字节二进制码（`E9 03 00 00`）搬到了硬盘。**这更高效，但不直接用记事本看。**

#### 3. `fseek` + `ftell` 的骚操作
这是 C 语言中获取文件大小的**标准姿势**：
1. 飞到末尾（`SEEK_END`）。
2. 问：“你在哪？”（`ftell`）。
3. 这个位置就是字节总数。

---

### 🚀 寒假自学任务：

把这段代码存为 `file_test.c`，在终端编译并运行：
```bash
gcc -Wall file_test.c -o file_test
./file_test
```

**运行之后，请观察：**
1.  左侧文件树是不是多了一个 `student.data`？
2.  试着用 VS Code 打开这个 `student.data`（它会提示你是二进制）。
3.  **终极思考**：在 `hexDump` 的结果中，你能不能找到结构体笔记里提到的 **Padding（内存对齐）** 的痕迹？（看看 `Alice` 后面是不是有一堆 `00` 被空出来了？）

**如果你能亲手跑通并观察到内存补齐，你对文件和内存的理解就已经达到了“准系统程序员”的水平！写好记得 Git Push！**