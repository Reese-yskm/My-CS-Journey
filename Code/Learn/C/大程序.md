# 大程序结构与模块化开发 (Modular Programming)

## 1. 编译单元与项目管理
*   **编译单元 (Compilation Unit)**：每一个 `.c` 源文件及其包含的头文件被视为一个独立的编译单元。
*   **独立编译**：编译器每次仅处理一个编译单元，并生成对应的目标文件（在 Linux 下为 `.o`，Windows 下为 `.obj`）。
*   **链接 (Linking)**：由**链接器 (Linker)** 将多个独立的目标文件“拼接”成最终的可执行程序。
    *   *NJU 视角*：下学期你会学到 `gcc` 后台调用的 `ld` 程序，它负责解决不同文件间的符号引用。

## 2. 头文件 (Header Files) 的角色
*   **本质**：头文件是不同编译单元之间的**公共契约**。
*   **内容**：头文件应仅包含**声明**（如函数原型、宏定义、结构体声明、`extern` 变量声明），而不包含任何实际产生机器指令或分配空间的**定义**。
*   **包含机制**：`#include` 是一个预处理指令，其动作是简单的**文本拷贝**。将头文件的内容原地展开到 `.c` 文件中。

## 3. 包含路径：`""` vs `<>`
*   **`#include "file.h"`**：搜索顺序为：
    1. 当前源文件所在目录；
    2. 编译器指定的包含路径（`-I` 参数）。
*   **`#include <file.h>`**：仅在编译器预设的标准库目录中搜索。
*   **注**：环境变量或 `Makefile` 中的 CFLAGS 可以动态改变这些搜索路径。

## 4. 声明 (Declaration) vs. 定义 (Definition)
这是大型工程中最易混淆的概念，必须严格区分：

| 特性         | 声明 (Declaration)           | 定义 (Definition)                              |
| :----------- | :--------------------------- | :--------------------------------------------- |
| **本质**     | 告知编译器对象的名称和类型   | 告知编译器分配具体的内存空间                   |
| **代码生成** | 不产生机器码，不占用存储空间 | 产生机器码，分配数据段或代码段空间             |
| **重复性**   | 同一作用域内可以多次声明     | **只能有一次定义**（One Definition Rule, ODR） |
| **关键字**   | `extern` 修饰变量；函数原型  | 函数体 `{...}`；变量初始化                     |

*   **`extern` 的作用**：告知当前编译单元，该变量定义在其他地方，链接时再去寻找其物理地址。

## 5. 头文件保护 (Header Guards)
*   **目的**：防止在一个编译单元中由于嵌套包含（A 包含 B，C 包含 A 和 B）导致同一声明被处理多次，引发重定义冲突。
*   **标准结构**：
    ```c
    #ifndef __LIST_HEAD__    // 检查宏是否未定义
    #define __LIST_HEAD__    // 定义该宏，锁定头文件
    
    /* 具体的声明内容 */
    
    #endif                   // 结束保护
    ```
*   **进阶用法**：现代编译器支持 `#pragma once`，功能相同且效率更高，但标准头文件结构（`#ifndef`）具有更好的跨编译器兼容性。

---

### 💡 [NJU ICS/PA 进阶建议]

1.  **静态链接与动态链接**：
    PA 实验中，你会通过 `Makefile` 自动化管理数十个编译单元。你会发现 `#include` 只是解决了编译器的语法检查，而最后的 `ld` 链接过程才是把分散的代码真正聚拢的时刻。
2.  **符号冲突 (Symbol Conflict)**：
    如果两个不同的 `.c` 文件定义了同名的全局变量（如 `int x;`），链接时会报错。解决方案是使用 `static` 关键字将变量限制在当前编译单元内，这叫**内部链接属性**。
3.  **头文件不包含代码**：
    **绝对不要**在头文件中写出具体的函数实现（除非是 `static inline` 函数）。如果在头文件里写了函数体，一旦该头文件被两个 `.c` 包含，链接器就会报 `multiple definition` 错误。

---

### 🚀 实战任务：
尝试在你的 GitHub 仓库中重构你之前的 C 代码：
1. 创建 `mylen.h` 存函数原型。
2. 创建 `mylen.c` 存函数实现。
3. 创建 `main.c` 只通过 `#include "mylen.h"` 来调用。
4. **手动尝试**：分别执行 `gcc -c mylen.c` 和 `gcc -c main.c` 生成 `.o` 文件，最后用 `gcc mylen.o main.o -o test` 完成手动链接。

**这种“手工拆解”的过程，会让你对 `gcc` 和大程序的本质有全新的认识。准备好 `git push` 你的第一个多文件项目了吗？**