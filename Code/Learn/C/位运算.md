# 位运算 (Bitwise Operations)

## 按位运算符

*   `&`：都为 1 才为 1，否则为 0
    *   **让某一位或某些位为 0**：通过构造掩码（Mask），让 0 屏蔽掉不需要的位。
    *   **取一个数中的一段**：例如 `x & 0xFF` 取出低 8 位。
*   `|`：只有全 0 为 0，否则为 1
    *   **使得一位或几个位为 1**：常用于设置标志位（Flag）。
    *   **把两个数拼起来**：例如将两个 8 位数拼成一个 16 位数。
*   `~`：每一位取反
    *   **注意**：在补码体制下，`~x` 等于 `-x - 1`。
*   `^`：两个位相等，结果为 0；不相等，结果为 1
    *   **自反性**：对一个变量用同一个值异或两次，等于什么也没做。`a ^ b ^ b == a`。
    *   **用于交换**：不使用临时变量交换 `a` 和 `b`：`a^=b; b^=a; a^=b;`。
*   `<<` (左移)：
    *   `i << j`：i 中所有的位向左移动 j 个位置，右边填入 0。
    *   **溢出风险**：移出的位会被丢弃，若将 1 移入符号位会改变正负。
    *   `x <<= n` 等价于 `x *= 2^n`。
*   `>>` (右移)：
    *   `i >> j`：i 中所有的位向右移动 j 个位置。
    *   **逻辑右移 (Logical Shift)**：对于 `unsigned` 类型，左边补 0。
    *   **算术右移 (Arithmetic Shift)**：对于 `signed` 类型，左边填入原来的**最高位**（即符号位），以保持数值的正负号不变。
    *   `x >>= n` 等价于 `x /= 2^n`。

---

## 重点：整数的补码表示 (Two's Complement)

> 在南大的 ICS（计算机系统基础）课程中，理解补码是所有实验的前提。

### 1. 为什么使用补码？
*   **统一加减法**：计算机底层只有加法器。通过补码，减法可以转化为加法：$a - b = a + (-b)$。
*   **0 的唯一性**：原码中有 $+0$ 和 $-0$ 之分，补码中 $0$ 的表示是唯一的。

### 2. 补码的转换规则
*   **正数**：补码 = 原码（最高位/符号位为 0）。
*   **负数**：补码 = 反码（原码除符号位外按位取反）+ 1。
    *   *快捷方法*：从右往左找第一个 1，该 1 左边的位全部取反，右边的位（包括该 1 自身）保持不变。

### 3. 符号扩展 (Sign Extension)
*   当你将一个窄类型（如 `char`）转换成宽类型（如 `int`）时：
    *   **无符号数**：高位直接补 0。
    *   **有符号数**：高位全部补**符号位**的值。这意味着补码表示的数值在扩展后保持不变。

---

## 例子：位运算实现加法

### 1. 核心逻辑推导
两个二进制数相加，其结果可以拆分为两个部分：
1.  **无进位和 (Sum without carry)**：
    *   规则：$0+0=0, 0+1=1, 1+0=1, 1+1=0$。
    *   **对应位运算**：**异或 (`^`)**。它被称为“二进制的不进位加法”。
2.  **进位 (Carry)**：
    *   规则：只有 $1+1$ 时才会产生进位。
    *   **对应位运算**：**与 (`&`)**。
    *   **修正**：进位必须作用于更高的一位，所以需要左移一位 (`<< 1`)。

### 递归公式：
$$a + b = (a \oplus b) + ((a \land b) \ll 1)$$
我们可以不断重复这个过程，直到“进位”变为 $0$ 为止。

---

### 2. 代码实现 (C 语言)

```c
#include <stdio.h>

int bitwise_add(int a, int b) {
    unsigned int carry;
    while (b != 0) {
        // 1. 计算进位：只有同为 1 的位才产生进位
        // 强制转换为 unsigned 是为了防止有符号移位导致的未定义行为
        carry = (unsigned int)(a & b) << 1;
        
        // 2. 计算无进位和
        a = a ^ b;
        
        // 3. 将进位赋值给 b，迭代处理
        b = carry;
    }
    return a;
}
```

---

### 3. 实例模拟：$5 + 7$
*   **$5$** 的二进制：`0101`
*   **$7$** 的二进制：`0111`

| 步骤      | `a` (当前和) | `b` (当前进位) | 说明                        |
| :-------- | :----------- | :------------- | :-------------------------- |
| **初始**  | `0101` (5)   | `0111` (7)     |                             |
| **第1轮** | `0010` (2)   | `1010` (10)    | `a^b=0010`, `(a&b)<<1=1010` |
| **第2轮** | `1000` (8)   | `0100` (4)     | `a^b=1000`, `(a&b)<<1=0100` |
| **第3轮** | `1100` (12)  | `0000` (0)     | `a^b=1100`, `(a&b)<<1=0000` |

---

### 4. 为什么这很“酷”？ (NJU 深度思考)
1.  **硬件原型**：这段代码其实就是计算机硬件里**全加器 (Full Adder)** 的算法逻辑。
2.  **ALU 的本质**：CPU 里的 ALU (算术逻辑单元) 只懂逻辑运算，它是通过这种组合完成所有算术任务的。

---

## 位段 (Bit-fields)

*   **定义**：把 `int` 的若干位组合成一个结构，允许按位粒度访问内存。
*   **语法**：
    ```c
    struct {
        unsigned int is_ready : 1;  // 占 1 位
        unsigned int error_code : 4; // 占 4 位
    } status;
    ```
*   **特性**：
    *   可以直接用成员名称访问。
    *   **不可移植性**：不同编译器、不同字节序（大端/小端）对位段的存储顺序不同。
    *   **内存对齐**：当所需的位超过一个 `int` 时会采用多个 `int`。
*   **工程用途**：常用于**直接映射硬件寄存器结构**，或者压缩存储空间。

---
*Next Step: 理解了位运算和补码后，你就可以自如地在 PA 实验中手动拆解和构造 CPU 指令了。*