# 《算法导论》第四章：分治策略 (Divide-and-Conquer)

## 1. 分治法的三个标准步骤
分治法的灵魂在于**递归**，每一层递归都有三个动作：
*   **分解 (Divide)：** 将大问题拆成几个规模更小的子问题。
*   **解决 (Conquer)：** 递归地求解子问题。如果子问题足够小（基本情况/Base Case），直接出解。
*   **合并 (Combine)：** 将子问题的解拼凑成原问题的解。

---

## 2. 什么是递归式 (Recurrence)？
递归式是一个等式或不等式，它用**更小输入上的函数值**来描述函数本身。

**核心公式：**
$$T(n) = aT(n/b) + f(n)$$
*   **$a$：** 分解出的子问题个数。
*   **$n/b$：** 每个子问题的规模。
*   **$f(n)$：** “分解”和“合并”这两步所花费的总代价（不包括递归本身）。

---

## 3. 求解递归式的“三剑客”
书中预告了三种方法，这是本章的核心技能：
1.  **代入法 (Substitution Method)：** 先猜一个答案，再用数学归纳法证明（适合数学大佬，需要直觉）。
2.  **递归树法 (Recursion-tree Method)：** 画一棵树，把每一层的代价加起来（最直观，能帮你理解原理）。
3.  **主方法 (Master Method)：** **最重要！** 这是一个现成的公式，只要符合 $T(n) = aT(n/b) + f(n)$ 的形式，套公式秒出答案。

---

## 4. 忽略“技术细节”的艺术 (图片第67页重点)
初学者往往会被递归式里的向上取整（$\lceil \rceil$）和向下取整（$\lfloor \rfloor$）搞晕。书里告诉了我们一个**程序员式的解脱**：

*   **忽略取整：** 当 $n=5$ 时，归并排序被分成 2 和 3。但在做渐进分析（写大 O 记号）时，我们可以直接当成 $5/2 = 2.5$。因为这些微小的偏误**不会改变函数增长的阶**。
*   **忽略边界：** 对于足够小的 $n$，$T(n)$ 往往是常数 $\Theta(1)$。我们在写递归式时，常常直接写：
    $$T(n) = 2T(n/2) + \Theta(n)$$
    而省略掉那个 $T(1) = \Theta(1)$。

---

## 💡 深度思考：如何理解归并排序的递归式？

回顾你之前写的代码，我们可以这样拆解归并排序的效率：
*   **Divide：** 找中点 $q = p + (r-p)/2$。代价是 $O(1)$。
*   **Conquer：** 递归跑两次，规模是原来的一半。代价是 $2T(n/2)$。
*   **Combine：** 把两个子数组合并（你的 `merge` 函数）。代价是 $O(n)$。

**合并起来：** $T(n) = 2T(n/2) + O(n)$。
通过递归树分析，每一层代价是 $n$，总共 $\log n$ 层，所以结果是 **$n \log n$**。

---



## 最大子数组

### 1. 问题背景：股票买卖
书里举了股票的例子。假设你有一张股票走势图，你想在某天买入，某天卖出，赚最多的钱。
*   **输入：** 一个包含数字的数组（代表价格的波动，有正有负）。
*   **目标：** 找到一段**连续**的子数组，使得它们的和最大。

**举例：** `[13, -3, -25, 20, -3, -16, -23, 18, 20, -7, 12, -5, -22, 15, -4, 7]`
最大子数组是 `[18, 20, -7, 12]`，和为 **43**。

---

### 2. 三种解法对比（感受算法的力量）

1.  **暴力求解 (Brute-force)：** 尝试所有可能的组合（从第 $i$ 个到第 $j$ 个）。
    *   时间复杂度：**$O(n^2)$**。
2.  **分治策略 (Divide and Conquer)：** 本章重点。
    *   时间复杂度：**$O(n \log n)$**。
3.  **线性求解 (Kadane算法)：** 课后思考题。
    *   时间复杂度：**$O(n)$**。

---

### 3. 分治法的核心逻辑：它在哪？

当我们把数组 $A[low...high]$ 从中间 $mid$ 劈开时，最大子数组**只有三种可能**的存在位置：

1.  **完全在左半部分：** $low \le i \le j \le mid$。
2.  **完全在右半部分：** $mid < i \le j \le high$。
3.  **跨越了中点：** $i \le mid < j$。

**这就是分治的神妙之处：**
*   前两种情况，我们直接交给**递归**去解决（因为它们又是规模更小的“最大子数组问题”）。
*   第三种情况“跨越中点”，我们需要写一个专门的函数 `FIND-MAX-CROSSING-SUBARRAY` 来处理。

---

### 4. 关键点：如何找“跨越中点”的最大子数组？

这是最容易卡住的地方。为什么找跨越中点的子数组只需要 $O(n)$ 时间？

*   因为既然它跨越了中点，那么它一定包含 $A[mid]$ 和 $A[mid+1]$。
*   **策略：**
    1.  从 $mid$ 开始向**左**扫描，找到以 $mid$ 结尾的最大子数组。
    2.  从 $mid+1$ 开始向**右**扫描，找到以 $mid+1$ 开始的最大子数组。
    3.  把左右两边的最大值**相加**，就是跨越中点的最大值。

**注意：** 因为这两次扫描都是单向的，所以只需要遍历一遍数组片段。

---

### 5. 代码逻辑实现（C语言伪代码化）

你可以试着把这个逻辑写成代码。核心结构如下：

```c
struct result {
    int left;
    int right;
    int sum;
};

// 1. 处理跨越中点的情况 (O(n))
struct result find_max_crossing_subarray(int *a, int low, int mid, int high) {
    int left_sum = -1e9; // 负无穷
    int sum = 0;
    int max_left;
    for (int i = mid; i >= low; i--) { // 向左找
        sum += a[i];
        if (sum > left_sum) {
            left_sum = sum;
            max_left = i;
        }
    }

    int right_sum = -1e9;
    sum = 0;
    int max_right;
    for (int j = mid + 1; j <= high; j++) { // 向右找
        sum += a[j];
        if (sum > right_sum) {
            right_sum = sum;
            max_right = j;
        }
    }
    return (struct result){max_left, max_right, left_sum + right_sum};
}

// 2. 主分治函数 (O(n log n))
struct result find_maximum_subarray(int *a, int low, int high) {
    if (low == high) return (struct result){low, high, a[low]}; // 递归终点

    int mid = (low + high) / 2;
    // 递归左半边
    struct result left_res = find_maximum_subarray(a, low, mid);
    // 递归右半边
    struct result right_res = find_maximum_subarray(a, mid + 1, high);
    // 处理跨越中点
    struct result cross_res = find_max_crossing_subarray(a, low, mid, high);

    // 返回三者中 sum 最大的那个
    if (left_res.sum >= right_res.sum && left_res.sum >= cross_res.sum) return left_res;
    else if (right_res.sum >= left_res.sum && right_res.sum >= cross_res.sum) return right_res;
    else return cross_res;
}
```

---

### 6. 为什么它是 $O(n \log n)$？

看它的递归式：
$$T(n) = 2T(n/2) + \Theta(n)$$
*   $2T(n/2)$ 是因为我们把数组分成了左右两半，分别递归。
*   $\Theta(n)$ 是 `find_max_crossing_subarray` 扫描数组的时间。

这个式子和**归并排序**一模一样！根据主定理，它的复杂度就是 $O(n \log n)$。



## 矩阵乘法的 Strassen 算法

Strassen 算法是算法导论中一个非常具有“颠覆性”的例子。在它出现之前，全世界的数学家都认为矩阵乘法的最快速度就是 $O(n^3)$。

Strassen 的出现告诉我们：**有时候，看起来理所当然的数学定义，在计算机算法面前是可以被“投机取巧”的。**

---

### 1. 背景：传统的矩阵乘法
假设我们要计算两个 $n \times n$ 的矩阵 $A$ 和 $B$ 的乘积 $C = A \cdot B$。

根据线性代数的定义：
$$C_{ij} = \sum_{k=1}^{n} A_{ik} \cdot B_{kj}$$
*   **分析：** 矩阵 $C$ 总共有 $n^2$ 个元素。计算每一个元素，都需要做 $n$ 次乘法和 $n-1$ 次加法。
*   **总复杂度：** $n^2 \cdot O(n) = \mathbf{O(n^3)}$。

### 2. 尝试用“分治法”解决（朴素分治）
为了使用分治法，我们将 $n \times n$ 的矩阵拆成 4 个 $(n/2) \times (n/2)$ 的小矩阵：
$$A = \begin{bmatrix} A_{11} & A_{12} \\ A_{21} & A_{22} \end{bmatrix}, B = \begin{bmatrix} B_{11} & B_{12} \\ B_{21} & B_{22} \end{bmatrix}$$
那么结果矩阵 $C$ 的四个部分为：
*   $C_{11} = A_{11}B_{11} + A_{12}B_{21}$
*   $C_{12} = A_{11}B_{12} + A_{12}B_{22}$
*   $C_{21} = A_{21}B_{11} + A_{22}B_{21}$
*   $C_{22} = A_{21}B_{12} + A_{22}B_{22}$

**复杂度分析：**
这里我们为了算出 $C$，总共做了 **8 次** 子矩阵乘法（例如 $A_{11}B_{11}$）和 **4 次** 子矩阵加法。
递归式为：$$T(n) = 8T(n/2) + \Theta(n^2)$$
*   根据主定理（后面会细讲），这个递归式的结果依然是 **$T(n) = \Theta(n^3)$**。
*   **结论：** 简单的分治并没有变快。

### 3. Strassen 的天才构想：8 变 7
Strassen 发现，矩阵乘法中最耗时的是**乘法**（递归调用），而**加法**相对很快（只需 $O(n^2)$）。

他通过一套复杂的数学组合（书上 71-72 页那一大堆 $P_1$ 到 $P_7$ 的公式），成功地用 **7 次矩阵乘法** 代替了原来的 8 次。

**他的步骤是：**
1.  创建 10 个辅助矩阵 $S_1, S_2, \dots, S_{10}$（通过子矩阵的加减法，耗时 $\Theta(n^2)$）。
2.  递归计算 **7 次** 子矩阵乘法，得到 $P_1, P_2, \dots, P_7$。
3.  通过对 $P_i$ 进行加减操作，直接组合出 $C_{11}, C_{12}, C_{21}, C_{22}$。

**新的递归式：**
$$T(n) = 7T(n/2) + \Theta(n^2)$$

### 4. 奇迹发生了：复杂度降阶
现在我们来计算这个新递归式的复杂度：
根据主定理，它的解是 $O(n^{\log_2 7})$。
因为 $\log_2 7 \approx 2.81$，所以：
$$\mathbf{O(n^{2.81})}$$

**这意味着什么？**
虽然看起来只从 3 降到了 2.81，但在计算机科学中，这是**巨大的突破**：
*   当 $n=100$ 时，$n^3 = 1,000,000$，而 $n^{2.81} \approx 416,869$。
*   当 $n$ 越大，Strassen 算法节省的时间就越恐怖。

---

### 5. 作为一个大一学生，你需要掌握到什么程度？

对于 Strassen 算法，你**不需要**背下那 7 条复杂的公式（$P_1 = A_{11}(B_{12} - B_{22})$ 等等），那是数学家的事。你需要掌握的是：

1.  **分治的核心思想：** 为什么减少一次递归调用（从 8 次变 7 次）能降低整体复杂度？（这是主定理最直观的体现）。
2.  **空间换时间：** Strassen 算法为了减少乘法，增加了很多额外的加法和临时矩阵，这反映了算法设计中的权衡。
3.  **实际应用中的局限性：** 
    *   **常数项大：** 只有当 $n$ 很大时（通常 $n > 100$ 或更大），Strassen 才会比传统方法快。
    *   **数值稳定性：** 由于频繁的加减法，浮点运算的精度损失比传统方法大。
    *   **内存消耗：** 创建那一大堆临时矩阵需要消耗更多空间。

---

### 💡 给你的学习建议

如果你想动手实现它，会发现它比之前的排序算法复杂得多。你需要：
*   先写一个处理矩阵加减法的函数。
*   处理 $n$ 不是 2 的幂的情况（通常在边缘补 0）。
*   设置一个“阈值”：当矩阵规模 $n$ 小于某个数（如 64）时，停止递归，直接用 $O(n^3)$ 的传统乘法（这叫**混合算法**，是工程中常用的手段）。

代入法（Substitution Method）是求解递归式最“数学化”的方法。如果说主定理（Master Method）是开箱即用的工具，那代入法就是**底层的数学证明**。

---

### 代入法求解递归式

#### 1. 核心思想
代入法本质上就是**数学归纳法**。它分为简单的两步：
1.  **猜测**解的形式（例如猜测 $T(n) = O(n \log n)$）。
2.  用**数学归纳法**求出常数，并证明解是正确的。

#### 2. 代入法的基本流程（以 $T(n) = 2T(\lfloor n/2 \rfloor) + n$ 为例）
*   **猜测：** $T(n) = O(n \lg n)$，即证明存在 $c$ 使得 $T(n) \le cn \lg n$。
*   **证明步骤：**
    1.  **假设**：对于所有 $m < n$，假设 $T(m) \le cm \lg m$ 成立。
    2.  **代入**：将 $m = n/2$ 代入原递归式：
        $$T(n) \le 2(c \lfloor n/2 \rfloor \lg \lfloor n/2 \rfloor) + n$$
        $$\le cn \lg(n/2) + n = cn \lg n - cn \lg 2 + n$$
        $$= cn \lg n - cn + n$$
    3.  **结论**：只要 $cn - n \ge 0$（即 $c \ge 1$），就有 $T(n) \le cn \lg n$。证明完毕。

#### 3. 两个重要的“技术细节”

*   **边界条件的陷阱（截图1）：**
    数学归纳法需要基本情况（Base Case）。有时 $n=1$ 时证明不通（如 $clg1 = 0$ 无法证明 $\ge T(1)$），但由于渐进记号只关心**足够大的 $n$**，我们可以**避开较小的 $n$**。
    *   *技巧*：改用 $n=2$ 和 $n=3$ 作为归纳的基础，只要选取的常数 $c$ 足够大，能盖住 $T(2)$ 和 $T(3)$ 即可。

*   **强化归纳假设（截图3）：**
    当你发现“差一点就证出来”的时候（比如多出了一个常数 1），**不要**轻易放弃或者改猜更大的界（比如从 $O(n)$ 改猜 $O(n^2)$）。
    *   *技巧*：从猜测中**减去一个低阶项**。
    *   *案例*：证明 $T(n) = T(n/2) + T(n/2) + 1$。如果猜 $T(n) \le cn$，会发现推导结果是 $T(n) \le cn + 1$，失败。
    *   *修正*：改猜 $T(n) \le cn - d$。推导后会发现只要 $d$ 选得合适，就能把多出来的“1”抵消掉。这在数学上叫**更强的归纳假设**。

#### 4. 如何做出“好猜测”？（截图2）
猜测不是瞎猜，有以下几种启发式方法：
1.  **套路法**：如果递归式和你见过的很像，就猜类似的解。
2.  **由松到紧**：先证明一个宽松的上界（如 $O(n^2)$）和下界（如 $\Omega(n)$），然后逐渐缩小范围。
3.  **递归树法**：这是 4.4 节的内容，通常先画递归树看个大概，再用代入法严谨证明。

#### 5. 避免陷阱：不要滥用 $O$ 符号（截图4）
在归纳证明的过程中，**绝对不能**在推导式里写 $T(n) \le 2T(n/2) + n \le cn + n = O(n)$。
*   **错误原因**：$O(n)$ 包含的是一个函数族，而归纳法要求证明的是**具体的函数形式**（如 $T(n) \le cn$）。必须显式地写出常数 $c$。

#### 6. 高级技巧：变量替换（截图4）
遇到“怪异”的递归式，比如 $T(n) = 2T(\lfloor \sqrt{n} \rfloor) + \lg n$，可以用变量替换法：
1.  令 $m = \lg n$，则 $n = 2^m$。
2.  原式变为 $T(2^m) = 2T(2^{m/2}) + m$。
3.  令 $S(m) = T(2^m)$，得到新递归式 $S(m) = 2S(m/2) + m$。
4.  这个形式非常眼熟，解是 $S(m) = O(m \lg m)$。
5.  回代：$T(n) = O(\lg n \lg \lg n)$。

---

### 递归树方法

#### 1. 核心定位
*   **用途**：最适合用来**生成猜测解**。
*   **特点**：允许一定程度的“不精确”（比如忽略取整），因为它只是为了给你一个直觉。得到猜测解后，通常再用**代入法**进行严谨验证。

#### 2. 如何画一棵递归树？
以 $T(n) = 3T(n/4) + cn^2$ 为例：
1.  **根节点**：表示当前层的代价（即递归式中的 $f(n)$ 项，这里是 $cn^2$）。
2.  **子节点**：将问题分解出的子问题。这里有 3 个分支，每个分支规模是 $n/4$。
3.  **逐层扩展**：对子节点重复上述过程，直到规模降为 1（叶节点）。

#### 3. 案例分析一：均匀分裂（$T(n) = 3T(n/4) + cn^2$）
通过观察截图中的图 4-5，我们可以得出：
*   **每一层的代价**：
    *   第 0 层（根）：$cn^2$
    *   第 1 层：$3 \times c(n/4)^2 = \frac{3}{16}cn^2$
    *   第 2 层：$9 \times c(n/16)^2 = (\frac{3}{16})^2 cn^2$
    *   第 $i$ 层：$(\frac{3}{16})^i cn^2$
*   **树的高度**：问题规模从 $n$ 降到 1，每次除以 4，高度为 $\log_4 n$。
*   **叶节点的总代价**：总共有 $3^{\log_4 n} = n^{\log_4 3}$ 个叶子，每个代价为 $T(1)$，总代价为 $\Theta(n^{\log_4 3})$。
*   **总和（关键推导）**：
    这是一个**等比级数**。因为公比 $\frac{3}{16} < 1$，所以这是一个**递减**级数。
    *   **结论**：总和由**根节点（第一项）支配**。即便加到无穷多项，总和也不会超过常数倍的 $cn^2$。
    *   **猜测解**：$T(n) = O(n^2)$。

#### 4. 案例分析二：不均匀分裂（$T(n) = T(n/3) + T(2n/3) + cn$）
这是截图 52 页中更复杂的情况。
*   **特征**：树是不平衡的（左边短，右边长）。
*   **每一层的代价**：神奇的是，在完全填满的层，每一层的和都是 $cn$。
*   **树的高度**：
    *   最短路径：$\log_3 n$
    *   最长路径：$\log_{3/2} n$
*   **总和推导**：
    所有层的代价和大概是：每层代价 $cn \times$ 树的高度。
    *   **猜测解**：$T(n) = O(n \lg n)$。

---

### 💡 深度总结：递归树的三种“命数”

你在分析递归树时，总和通常会呈现以下三种趋势之一：

1.  **根节点支配（代价逐层递减）**：
    *   如 $T(n) = 3T(n/4) + cn^2$。
    *   能量大部分消耗在递归的顶层。
    *   结论通常是 $T(n) = \Theta(f(n))$。

2.  **叶节点支配（代价逐层递增）**：
    *   如果公比大于 1（例如 $T(n) = 4T(n/2) + n$）。
    *   能量大部分消耗在递归的最底层（小碎活儿太多了）。
    *   结论通常是 $T(n) = \Theta(n^{\log_b a})$。

3.  **各层平分秋色（每层代价相等）**：
    *   如归并排序 $T(n) = 2T(n/2) + cn$。
    *   每一层代价都是 $cn$。
    *   结论通常是 $T(n) = \Theta(f(n) \lg n)$。

---

## 主方法 (Master Method)。

---

### 1. 适用范围 (Standard Form)
主方法只能用于以下格式的递归式：
$$T(n) = aT(n/b) + f(n)$$

*   **$a \ge 1$**：子问题的个数（必须是常数）。
*   **$b > 1$**：每个子问题的规模（必须是常数）。
*   **$f(n)$**：分解和合并产生的代价。

---

### 2. 核心思想：一场“势均力敌”的较量
主方法的本质是比较 **$f(n)$**（根节点的代价）和 **$n^{\log_b a}$**（叶节点的总代价）谁更强。

*   **$n^{\log_b a}$** 是通过递归分裂产生的“基础劳动力”（底层的活儿）。
*   **$f(n)$** 是每一层合并时产生的“管理成本”（顶层的活儿）。

---

### 3. 主方法的三种情况 (The Three Cases)

我们要比较 $f(n)$ 和 $n^{\log_b a}$ 的量级：

#### **Case 1：小弟干活（叶节点支配）**
如果 $n^{\log_b a}$ 的量级**显著大于** $f(n)$：
*   **结果**：$T(n) = \Theta(n^{\log_b a})$
*   **直观理解**：底层的碎活儿太多了，成了性能瓶颈，顶层的合并代价可以忽略不计。
*   **例子**：$T(n) = 8T(n/2) + n^2$
    *   $n^{\log_b a} = n^{\log_2 8} = n^3$
    *   $n^3$ 远大于 $n^2$，所以 $T(n) = \Theta(n^3)$。

#### **Case 2：平分秋色（各层均衡）**
如果 $f(n)$ 和 $n^{\log_b a}$ **同阶**：
*   **结果**：$T(n) = \Theta(n^{\log_b a} \lg n)$
*   **直观理解**：每一层的代价都差不多，所以总代价就是“一层的代价 $\times$ 树的高度 ($\lg n$)”。
*   **例子**：**归并排序** $T(n) = 2T(n/2) + n$
    *   $n^{\log_b a} = n^{\log_2 2} = n^1$
    *   $f(n) = n$，两者一样。
    *   所以 $T(n) = \Theta(n \lg n)$。

#### **Case 3：大佬带飞（根节点支配）**
如果 $f(n)$ 的量级**显著大于** $n^{\log_b a}$：
*   **结果**：$T(n) = \Theta(f(n))$
*   **直观理解**：顶层的合并操作太重了，底层那点小活儿跟它比起来不算什么。
*   **条件**：除了量级大，还需要满足一个“正则性条件”（通常 $n^k$ 这种多项式都满足）。
*   **例子**：$T(n) = T(n/2) + n^2$
    *   $n^{\log_b a} = n^{\log_2 1} = n^0 = 1$
    *   $f(n) = n^2$ 远大于 $1$。
    *   所以 $T(n) = \Theta(n^2)$。

---

### 4. 常见的算法快速套用

| 算法           | 递归式                 | $a, b, f(n)$ | 结果                | 主方法情况                   |
| :------------- | :--------------------- | :----------- | :------------------ | :--------------------------- |
| **二分查找**   | $T(n) = T(n/2) + 1$    | $1, 2, 1$    | $\Theta(\lg n)$     | Case 2 ($n^0$ vs $1$)        |
| **归并排序**   | $T(n) = 2T(n/2) + n$   | $2, 2, n$    | $\Theta(n \lg n)$   | Case 2 ($n^1$ vs $n$)        |
| **Strassen**   | $T(n) = 7T(n/2) + n^2$ | $7, 2, n^2$  | $\Theta(n^{\lg 7})$ | Case 1 ($n^{2.81}$ vs $n^2$) |
| **最大子数组** | $T(n) = 2T(n/2) + n$   | $2, 2, n$    | $\Theta(n \lg n)$   | Case 2                       |

---

### 5. 注意事项 (主方法的盲区)

主方法虽然强，但不是万能的，有些情况它**解不了**：

1.  **$a$ 不是常数**：比如 $T(n) = n T(n/2) + n$。
2.  **$f(n)$ 和 $n^{\log_b a}$ 之间不是“多项式大于”**：比如差一个 $\lg n$。
    *   经典反例：$T(n) = 2T(n/2) + n \lg n$。
    *   虽然 $n \lg n$ 比 $n$ 大，但它不是**多项式**意义上的大（即没有大出一个 $n^\epsilon$）。这时候主方法失效，得用递归树。
3.  **不符合 $aT(n/b)$ 形式**：比如 $T(n) = T(n-1) + 1$（线性递归），这种只能用代入法或递归树。

---

### 💡 学习总结笔记

作为大一学生，你只需要记住一句话：**看分裂的速度（$a, b$）快，还是合并的速度（$f(n)$）快。**

*   如果分裂出的子问题太多、规模缩减太慢（Case 1），底层就累死。
*   如果合并操作太复杂（Case 3），顶层就累死。
*   如果两边节奏一致（Case 2），大家平摊，最后加个 $\lg n$。

---

