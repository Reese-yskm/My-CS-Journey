# 第十五章：动态规划 (Dynamic Programming) —— “记忆”的艺术

### 1. 核心思想：不要重复你自己
如果你问一个刚学编程的人：“斐波那契数列第 100 项是多少？”他可能会写一个递归。
*   **递归的问题**：它会不断地重复计算相同的问题（比如为了算 $F(5)$，它会算很多次 $F(2)$）。这在计算上是**暴力和浪费**。
*   **DP 的天才想法**：**既然算过一遍了，为什么不拿个小本本记下来呢？** 下次用到，直接查表。

这就是 DP 的本质：**用空间换时间**。

### 2. 动态规划的四大特征（判断能不能用 DP）
1.  **最优子结构**：问题的最优解包含其子问题的最优解。
2.  **重叠子问题**：递归过程中，相同的子问题会被反复遇到。
3.  **无后效性**：一旦子问题的解确定，就不会受后面决策的影响（“往事不可追”）。

---

### 3. 经典入门：钢条切割问题 (Rod Cutting)

**场景**：你有一段长度为 $n$ 英寸的钢条，不同长度的钢条价格不同。如何切割能卖最高价？

*   **暴力递归**：如果你用穷举，复杂度是 $O(2^n)$。当 $n=40$ 时，电脑可能就要跑好几分钟了。
*   **动态规划**：
    *   我们从长度为 1 开始算，算出长度为 1 的最高价，记下来。
    *   再算长度为 2 的，它可能是（1+1）或者（直接2不切）。因为我们已经知道 1 的最高价了，直接查表比对。
    *   ...
    *   **结果**：复杂度直接降到 **$O(n^2)$**。刚才要跑几分钟的程序，现在不到一毫秒就出结果。

---

### 4. 动态规划的两种实现套路

1.  **带备忘录的自顶向下 (Top-down with memoization)**：
    *   还是写递归，但在递归里加一个 `if (memo[n] != -1) return memo[n]`。
    *   这是“聪明”的递归。
2.  **自底向上 (Bottom-up)**：
    *   不用递归，直接用 `for` 循环从最小的问题开始填表。
    *   这是最常用的，也是性能最稳的。

---

### 5. C++ 代码：钢条切割的 DP 实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

// p 是价格表，n 是钢条总长度
int bottom_up_cut_rod(const vector<int>& p, int n) {
    vector<int> r(n + 1, 0); // r[i] 存储长度为 i 的钢条的最大收益

    for (int j = 1; j <= n; j++) {
        int q = -1;
        // 尝试每一种切割位置 i
        for (int i = 1; i <= j; i++) {
            // 核心状态转移方程：
            // 长度 j 的最大收益 = max(当前最大收益, 长度 i 的价格 + 长度 j-i 的已求得最大收益)
            q = max(q, p[i] + r[j - i]);
        }
        r[j] = q; // 记下长度 j 的最优解
    }
    return r[n];
}

int main() {
    // 价格表：下标为长度，值为价格 (第0位不用)
    vector<int> prices = {0, 1, 5, 8, 9, 10, 17, 17, 20, 24, 30};
    int length = 10;

    printf("--- 1. Rod Cutting DP Test ---\n");
    int max_profit = bottom_up_cut_rod(prices, length);
    printf("Max profit for length %d is: %d\n", length, max_profit);

    return 0;
}
```

---



## 矩阵链乘法

### 1. 问题的由来：括号的位置决定生死

在线性代数中，矩阵乘法满足**结合律**：$(A \cdot B) \cdot C = A \cdot (B \cdot C)$。
虽然结果一样，但**计算代价（标量乘法次数）**却天差地别。

**举个例子：**
假设有三个矩阵：$A_1(10 \times 100)$, $A_2(100 \times 5)$, $A_3(5 \times 50)$。
*   **方式一：$(A_1 A_2) A_3$**
    1. 计算 $A_1 A_2$：次数为 $10 \times 100 \times 5 = 5000$。得到 $10 \times 5$ 的矩阵。
    2. 再乘以 $A_3$：次数为 $10 \times 5 \times 50 = 2500$。
    3. **总次数：7500**。
*   **方式二：$A_1 (A_2 A_3)$**
    1. 计算 $A_2 A_3$：次数为 $100 \times 5 \times 50 = 25000$。得到 $100 \times 50$ 的矩阵。
    2. $A_1$ 再乘以它：次数为 $10 \times 100 \times 50 = 50000$。
    3. **总次数：75000**。

**结论：** 第二种比第一种慢了 **10 倍**！如果矩阵更多，这个差距会变成成千上万倍。

---

### 2. 动态规划的拆解

我们要找到一种加括号的方式，使得 $n$ 个矩阵相乘的总次数最少。

#### 第一步：最优子结构
假设我们在第 $k$ 个矩阵处把链断开：$(A_i \dots A_k) \cdot (A_{k+1} \dots A_j)$。
要使整体代价最小，那么 $A_i \dots A_k$ 和 $A_{k+1} \dots A_j$ 这两部分本身也必须是各自最优的。

#### 第二步：状态转移方程
设 $m[i, j]$ 为计算矩阵序列 $A_i \dots A_j$ 所需的最小乘法次数。
如果矩阵 $A_i$ 的维数是 $p_{i-1} \times p_i$，那么：
$$m[i, j] = \min_{i \le k < j} \{ m[i, k] + m[k+1, j] + p_{i-1} \cdot p_k \cdot p_j \}$$
*   **$m[i, k]$**：前一部分的代价。
*   **$m[k+1, j]$**：后一部分的代价。
*   **$p_{i-1} \cdot p_k \cdot p_j$**：最后把这两部分乘起来的代价。

---

### 3. 天才的填表方式：按长度填表

在之前的钢条切割中，我们是按长度 $1, 2, 3 \dots$ 填表。
在矩阵链中，我们是按**链的长度**填表：
1. 先算出所有长度为 2 的矩阵链的最优解。
2. 再利用长度为 2 的结果，算出所有长度为 3 的。
3. ...直到算出长度为 $n$ 的。

---

### 4. C++ 代码实现 (English Output)

这段代码不仅会算出最少次数，还会记录路径并打印出**加括号的最佳方案**。

```cpp
#include <iostream>
#include <vector>
#include <climits>

using namespace std;

// 打印最佳加括号方案的递归函数
void print_optimal_parens(const vector<vector<int>>& s, int i, int j) {
    if (i == j) {
        cout << "A" << i;
    } else {
        cout << "(";
        print_optimal_parens(s, i, s[i][j]);
        print_optimal_parens(s, s[i][j] + 1, j);
        cout << ")";
    }
}

void matrix_chain_order(const vector<int>& p) {
    int n = p.size() - 1; // 矩阵个数
    // m[i][j] 存储最小乘法次数
    vector<vector<int>> m(n + 1, vector<int>(n + 1, 0));
    // s[i][j] 存储获得最优解时的分割点 k
    vector<vector<int>> s(n + 1, vector<int>(n + 1, 0));

    // l 是链的长度 (从长度 2 开始)
    for (int l = 2; l <= n; l++) {
        for (int i = 1; i <= n - l + 1; i++) {
            int j = i + l - 1;
            m[i][j] = INT_MAX;
            // 尝试每一个可能的分割点 k
            for (int k = i; k <= j - 1; k++) {
                int q = m[i][k] + m[k+1][j] + p[i-1] * p[k] * p[j];
                if (q < m[i][j]) {
                    m[i][j] = q;
                    s[i][j] = k;
                }
            }
        }
    }

    cout << "--- Matrix Chain Multiplication DP Test ---" << endl;
    cout << "Minimum number of multiplications: " << m[1][n] << endl;
    cout << "Optimal Parenthesization: ";
    print_optimal_parens(s, 1, n);
    cout << endl;
}

int main() {
    // 矩阵维数: A1(30x35), A2(35x15), A3(15x5), A4(5x10), A5(10x20), A6(20x25)
    // p 数组存储的是 [30, 35, 15, 5, 10, 20, 25]
    vector<int> p = {30, 35, 15, 5, 10, 20, 25};
    
    matrix_chain_order(p);

    return 0;
}
```

---



## 最长公共子序列 (LCS)

### 1. 问题的定义：什么是“子序列”？

首先要区分两个极其相似的概念：
*   **子串 (Substring)**：必须是**连续**的。比如 `ABC` 是 `ABCDE` 的子串。
*   **子序列 (Subsequence)**：可以不连续，但**相对顺序**不能乱。比如 `ACE` 是 `ABCDE` 的子序列。

**问题：** 给定两个字符串 $X$ 和 $Y$，求它们最长的公共子序列的长度。
**例子：**
$X = \text{ABCBDAB}$
$Y = \text{BDCABA}$
它们的 LCS 之一是 $\text{BCBA}$，长度为 4。

---

### 2. 天才的思考：如何拆解问题？

我们要比较 $X[1 \dots i]$ 和 $Y[1 \dots j]$。

**核心逻辑（三种情况）：**
1.  **末尾字符相同** ($X[i] == Y[j]$)：
    *   这太棒了！这个字符一定是 LCS 的一部分。
    *   **动作**：$LCS = 1 +$ (去掉末尾后的 LCS)。
2.  **末尾字符不同** ($X[i] \neq Y[j]$)：
    *   说明这两个末尾字符不可能**同时**出现在 LCS 里。
    *   **动作**：我们要看是“舍弃 $X$ 的末尾”比较好，还是“舍弃 $Y$ 的末尾”比较好。
    *   **公式**：$LCS = \max(\text{LCS}(X[i-1], Y[j]), \text{LCS}(X[i], Y[j-1]))$。

---

### 3. 状态转移方程

设 $c[i, j]$ 为序列 $X_i$ 和 $Y_j$ 的 LCS 长度：
$$c[i, j] = 
\begin{cases} 
0 & \text{if } i=0 \text{ or } j=0 \\
c[i-1, j-1] + 1 & \text{if } X[i] = Y[j] \\
\max(c[i-1, j], c[i, j-1]) & \text{if } X[i] \neq Y[j]
\end{cases}$$

---

### 4. 填表与还原解

*   **填表**：我们会得到一个二维矩阵。
*   **还原解**：和矩阵链乘法一样，我们通常会再开一个表 $b[i, j]$，记录我们当时选了哪条路：
    *   `↖`：表示字符匹配。
    *   `↑`：表示选了上面的（舍弃 $X$ 的一个字符）。
    *   `←`：表示选了左边的（舍弃 $Y$ 的一个字符）。

---

### 5. C++ 代码实现 (English Output)

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <algorithm>

using namespace std;

// 打印 LCS 的递归函数
void print_lcs(const vector<vector<char>>& b, const string& X, int i, int j) {
    if (i == 0 || j == 0) return;
    
    if (b[i][j] == 'D') { // Diagonal ↖
        print_lcs(b, X, i - 1, j - 1);
        cout << X[i - 1]; // 注意下标对齐
    } else if (b[i][j] == 'U') { // Up ↑
        print_lcs(b, X, i - 1, j);
    } else { // Left ←
        print_lcs(b, X, i, j - 1);
    }
}

void lcs_length(string X, string Y) {
    int m = X.length();
    int n = Y.length();
    
    // c 表存长度，b 表存方向
    vector<vector<int>> c(m + 1, vector<int>(n + 1, 0));
    vector<vector<char>> b(m + 1, vector<char>(n + 1));

    for (int i = 1; i <= m; i++) {
        for (int j = 1; j <= n; j++) {
            if (X[i - 1] == Y[j - 1]) {
                c[i][j] = c[i - 1][j - 1] + 1;
                b[i][j] = 'D'; // Diagonal
            } else if (c[i - 1][j] >= c[i][j - 1]) {
                c[i][j] = c[i - 1][j];
                b[i][j] = 'U'; // Up
            } else {
                c[i][j] = c[i][j - 1];
                b[i][j] = 'L'; // Left
            }
        }
    }

    cout << "--- Longest Common Subsequence DP Test ---" << endl;
    cout << "Length of LCS: " << c[m][n] << endl;
    cout << "LCS Result: ";
    print_lcs(b, X, m, n);
    cout << endl;
}

int main() {
    string X = "ABCBDAB";
    string Y = "BDCABA";
    
    lcs_length(X, Y);
    
    return 0;
}
```



---

### 📖 LCS 动态规划图解笔记

#### 1. 表格的构成
*   **第一行与第一列（标红的 0）**：代表其中一个字符串为空串 ($\emptyset$) 的情况。
    *   *意义*：任何字符串与空串的公共子序列长度都是 0。这是 DP 的**初始条件**。
*   **单元格中的数字 $D_{ij}$**：代表字符串 $S1$ 的前 $i$ 个字符与 $S2$ 的前 $j$ 个字符的 **最长公共子序列长度**。

#### 2. 递推公式与箭头的含义（灵魂所在）

你在图中看到的箭头，其实就是算法在做**决策**时的记录。

| 场景                              | 状态转移方程                          | 箭头方向                                     | 背后的人话逻辑                                               |
| :-------------------------------- | :------------------------------------ | :------------------------------------------- | :----------------------------------------------------------- |
| **字符匹配** ($S1_i == S2_j$)     | $D_{ij} = 1 + D_{i-1,j-1}$            | **斜向上 ($\nwarrow$)**                      | “太棒了，这两个字母一样！我们在去掉这两个字母后的 LCS 基础上，长度加 1。” |
| **字符不匹配** ($S1_i \neq S2_j$) | $D_{ij} = \max(D_{i,j-1}, D_{i-1,j})$ | **向上 ($\uparrow$) 或 向左 ($\leftarrow$)** | “这两个字母不同，我们要看看是‘少看 $S1$ 的最后一个’比较强，还是‘少看 $S2$ 的最后一个’比较强。” |

#### 3. 模拟填表过程 (以图为例)
*   看图中第 4 行第 4 列（字符 A 和 A 碰头时）：
    *   因为 A == A，所以看它的**左上方**单元格（数字是 0），加 1 得到 **1**，画个斜箭头 $\nwarrow$。
*   看图中第 5 行第 6 列（字符 B 和 B 碰头时）：
    *   因为 B == B，看它的**左上方**（数字是 1），加 1 得到 **2**，画个斜箭头 $\nwarrow$。

#### 4. 如何找最终答案？（逆向回溯）
当你填完右下角的最后一个数字（图中是 **4**）后，顺着箭头往回走：
1.  **遇到斜箭头 ($\nwarrow$)**：说明这个位置对应的字母是“公共字符”，**记下来**，然后跳到左上方。
2.  **遇到上或左箭头**：说明这里没匹配上，顺着箭头走，不记录字符。
3.  **最后把记下来的字符“倒序”排列**：就是我们要找的最长公共子序列。

---

### 💡 助教给学弟的“看图心得”

*   **空间压缩的启发**：看这张图，你会发现算某一个格子的数字时，其实只用到了它的**左边、上面、和左上方**。这意味着，我们其实不需要存整个二维大表格。如果你能用**两行数组**滚动更新，就能把 $O(m \cdot n)$ 的空间复杂度优化到 $O(\min(m, n))$。
*   **最优子结构的可视化**：每一个格子里的数字，都是基于它“左上角那一小块世界”的最优解推导出来的。



## 最优二叉搜索树 (Optimal BST)

### 1. 问题的由来：为什么要“最优”？
在前十二章中，我们学过红黑树等平衡二叉树，它们保证了最坏情况下的搜索时间是 $O(\lg n)$。

**天才的质疑：**
如果每个单词被搜索的频率是不一样的呢？
*   比如在英语词典里，“the” 可能被搜索 1000 次，而 “machicolation” 可能只被搜索 1 次。
*   如果我们把 “the” 放在树的深处（靠近叶子），把 “machicolation” 放在根部，虽然树是平衡的，但**平均搜索时间**会非常长。

**目标：** 给定一组关键字的**搜索频率**，构造一棵二叉搜索树，使得**搜索的总期望代价最小**。

---

### 2. 问题的数学模型
*   **关键字 $k_1, k_2, \dots, k_n$**：我们要找的目标。
*   **搜索概率 $p_i$**：搜索关键字 $k_i$ 的概率。
*   **伪关键字 $d_0, d_1, \dots, d_n$**：代表“搜索失败”的情况（比如搜一个不存在于词典的词）。
*   **搜索概率 $q_i$**：搜索落入范围 $(k_i, k_{i+1})$ 的概率。

**期望代价公式：**
$$E = \sum_{i=1}^n (depth(k_i) + 1) \cdot p_i + \sum_{j=0}^n (depth(d_j) + 1) \cdot q_j$$
*注：深度是从 0 开始算的，所以公式里要 +1。*

---

### 3. 为什么是动态规划？（最优子结构）
最优二叉搜索树展现了完美的**最优子结构**：
*   如果一棵树 $T$ 是最优的，那么它的**左子树 $L$** 和 **右子树 $R$** 也必须分别是它们所包含的关键字集合下的最优二叉搜索树。

**证明思路：** 剪贴法（和钢条切割、矩阵链乘法一样）。如果左子树不是最优的，我们换一棵更好的左子树，整棵树的代价就会降低。

---

### 4. 状态转移方程（最天才的一步）

设 $e[i, j]$ 为包含关键字 $k_i \dots k_j$ 的最优 BST 的期望代价。

如果我们选 $k_r$ 作为根节点（$i \le r \le j$）：
1.  左子树包含 $k_i \dots k_{r-1}$，代价为 $e[i, r-1]$。
2.  右子树包含 $k_{r+1} \dots k_j$，代价为 $e[r+1, j]$。
3.  **关键点：** 当这两棵子树挂在根 $k_r$ 下面时，它们所有节点的深度都**增加了 1**。
    *   根据期望公式，深度增加 1，意味着总代价要多加上**这棵子树内所有节点的概率总和 $w(i, j)$**。

**方程：**
$$e[i, j] = \min_{i \le r \le j} \{ e[i, r-1] + e[r+1, j] + w(i, j) \}$$
其中 $w(i, j)$ 是子树概率之和：$w(i, j) = \sum_{l=i}^j p_l + \sum_{l=i-1}^j q_l$。

---

### 5. 与“矩阵链乘法”的血缘关系
你发现了吗？这个方程的形式和矩阵链乘法惊人地相似：
*   **矩阵链**：是在一串矩阵里选一个地方断开。
*   **最优 BST**：是在一串关键字里选一个当根（断开）。
*   **填表顺序**：也是**按长度填表**。先算长度为 1 的树，再算长度为 2 的……最后算到 $n$。
*   **复杂度**：同样是 **$O(n^3)$**。

---

### 6. 💡 助教的深度思考：Optimal BST vs Huffman Coding

这是很多大一学生会混淆的点：
*   **哈夫曼编码（贪心）**：它也是为了最小化期望长度。但它**不要求**保持顺序。它只需要把频率高的放上面。
*   **最优 BST（动规）**：它**必须保持二叉搜索树的顺序**（左小右大）。
*   **结论**：
    *   如果你不需要搜索（只需解码），用哈夫曼（更快，$O(n \lg n)$）。
    *   如果你需要支持二分搜索，必须用最优 BST（稍慢，$O(n^3)$）。

