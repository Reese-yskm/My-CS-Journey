# 《算法导论》学习笔记：第一、二章

## 第一章：算法在计算中的角色
*   **算法的定义：** 算法是将**输入**转换为**输出**的计算步骤序列。它像是一份菜谱，描述了处理数据的精确方法。
*   **为什么要学算法？**
    *   计算机硬件虽然快，但内存和时间是有限资源。
    *   算法是衡量程序员“内功”的指标：同样的功能，$O(n^2)$ 和 $O(n \log n)$ 在大数据量下是天壤之别。

---

## 第二章：开始学习 (入门指南)

### 1. 插入排序 (Insertion Sort) —— “摸牌思想”
*   **核心逻辑：** 将数组分为“已排序”和“未排序”两部分。每次从未排序部分取出一个数，插入到已排序部分的正确位置。
*   **循环不变式 (Loop Invariant)：** 这是证明算法正确性的核心工具。
    *   **初始：** 循环第一次迭代前，子数组 $A[0..0]$ 是有序的。
    *   **保持：** 如果 $A[0..i-1]$ 有序，那么插入 $A[i]$ 后，$A[0..i]$ 依然有序。
    *   **终止：** 循环结束时，整个数组有序。
*   **时间复杂度：**
    *   最坏情况：$O(n^2)$（数组逆序）。
    *   最好情况：$O(n)$（数组已有序）。

### 2. 算法分析基础
*   **输入规模 ($n$)：** 元素的个数。
*   **运行时间：** 执行的原始操作次数。
*   **最坏情况分析 (Worst-case Analysis)：** 
    *   算法学界通常只关注最坏情况。
    *   理由：它给出了运行时间的**上界**；最坏情况经常发生（如搜索不存在的数）。
*   **增长量级 (Order of Growth)：** 
    *   我们忽略常数项和低阶项（例如 $3n^2 + 10n + 5 \approx \Theta(n^2)$）。
    *   因为当 $n$ 足够大时，高阶项决定了运行效率。

### 3. 分治法 (Divide and Conquer) —— 归并排序的核心
分治法的三个步骤：
1.  **分解 (Divide)：** 将原问题分解为若干个规模较小的子问题。
2.  **解决 (Conquer)：** 递归地解这些子问题。如果子问题足够小（底层），则直接求解。
3.  **合并 (Combine)：** 将子问题的解合并成原问题的解。

### 4. 归并排序 (Merge Sort)
*   **性能：** 时间复杂度始终是 $\Theta(n \log n)$。
*   **空间：** 需要额外的 $O(n)$ 空间来存放临时数组（不是原地排序）。
*   **实现要点（C语言避坑）：**
    *   **下标：** CLRS 伪代码通常以 1 为基准，C 语言必须转换为 0。
    *   **中点计算：** `q = (p + r) / 2` 可能会溢出，更稳健写法是 `q = p + (r - p) / 2`。
    *   **合并逻辑：** 合并两个有序数组时，要注意其中一个数组先取完的情况（使用“哨兵”或直接处理剩余元素）。

---

## 💡 实践总结（你的心得）

1.  **伪代码 vs 实际代码：** 
    *   伪代码省略了内存分配和具体的边界检查。
    *   在 C 语言中，一定要警惕 `a[p + i - 1]` 这种下标操作，防止访问非法地址。

2.  **递归的深度：**
    *   归并排序的递归树深度是 $\log_2 n$。即使 $n=1,000,000$，深度也只有约 20 层，所以不用担心栈溢出，但要注意内存占用。

3.  **调试技巧：**
    *   在 `merge` 之前和之后打印当前子数组的状态，是理解分治过程最直观的方法。

