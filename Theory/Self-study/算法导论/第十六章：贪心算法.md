# 《算法导论》第十六章：贪心算法 (Greedy Algorithms) 详细笔记

## 1. 贪心算法的核心哲学
*   **贪心选择性质 (Greedy Choice Property)**：我们可以通过做出**局部最优**（当前最好）的选择来构造全局最优解。
*   **与 DP 的区别**：
    *   **动态规划**：每一步的选择取决于子问题的解。因此通常是**自底向上**计算（先看子问题，再做当前决策）。
    *   **贪心算法**：在做当前选择时，不依赖子问题的解。它通常是**自顶向下**的，做一个选择，然后缩减问题规模。

---

## 2. 经典案例 1：活动选择问题 (Activity-Selection Problem)

这是贪心算法的“开场秀”，展示了如何通过简单的排序和筛选解决复杂的调度问题。

### 问题描述：
有一组活动 $S = \{a_1, a_2, \dots, a_n\}$，每个活动有开始时间 $s_i$ 和结束时间 $f_i$。目标是在同一间教室内安排**尽可能多**的不冲突活动。

### 天才的贪心策略：
**每次都选择结束时间 $f_i$ 最早的活动。**

*   **直觉**：结束得越早，留给后面活动的时间就越多。
*   **算法步骤**：
    1.  按结束时间 $f_i$ 对活动进行**升序排列**。
    2.  选取第一个活动 $a_1$。
    3.  遍历剩下的活动，如果某个活动的 $s_i \ge$ 上一个选中活动的 $f_{last}$，则选中它。

### 为什么它是正确的？
《算法导论》证明了：在所有兼容的活动中，结束时间最早的活动必然属于某个最优解。通过不断的“贪心选择+缩减问题”，最终得到全局最大数量。

---

## 3. 贪心算法的两大要素 (理论支柱)

要证明一个问题可以用贪心算法，必须证明以下两点：

1.  **贪心选择性质**：我们可以通过局部最优选择达到全局最优。
2.  **最优子结构**：一个问题的最优解包含其子问题的最优解。

### 🚨 警示：贪心算法的局限性
贪心算法**并不对所有问题都有效**。如果局部最优导致无法达到全局最优，就必须退回到动态规划。

**经典对比：背包问题 (The Knapsack Problem)**
*   **0-1 背包问题**（物品不能拆分）：**贪心法无效**。你拿了单位价值最高的，可能导致空间浪费，反而不如拿两个次优的。必须用 **DP**。
*   **分数背包问题**（物品可以拆分，如金粉）：**贪心法有效**。直接按单位价值（价值/重量）排序，从高往低拿即可。

---

## 4. 经典案例 2：赫夫曼编码 (Huffman Codes)

这是贪心算法在**数据压缩**领域的伟大应用，也是你之前学过的“二叉树”和“堆”的完美结合。

### 背景：
如何用最少的二进制位表示一段文本？
*   **定长编码**：每个字母都用 3 位（如 ASCII）。
*   **变长编码**：给频率高的字母短编码（如 'e' 用 `01`），给频率低的字母长编码（如 'z' 用 `1101`）。

### 天才的约束：前缀码 (Prefix Codes)
为了避免歧义（比如 `01` 是 'a'，`011` 是 'b'，那收到 `011` 时该怎么解？），赫夫曼采用了**前缀码**：没有任何一个编码是另一个编码的前缀。这在逻辑上表现为：**所有字母都在二叉树的叶子节点上。**

### 赫夫曼算法逻辑（贪心策略）：
1.  计算每个字符出现的频率。
2.  将所有字符看作单节点树，放入一个**最小优先队列（最小堆）**。
3.  **贪心步骤**：每次从堆中弹出**频率最低**的两个节点，合成为一个新节点，频率为两者之和。
4.  将新节点插回堆。
5.  重复直到堆中只剩一个根节点。

**复杂度**：$O(n \lg n)$，主要花在优先队列的操作上。

---

## 5. 拟阵理论 (Matroids) —— 贪心的数学根基（进阶内容）

《算法导论》在 16.4 节引入了**拟阵**。这部分数学味很浓，大一学生可以先理解结论：
*   拟阵是一个数学结构，如果一个问题能证明符合“拟阵”的公理，那么**贪心算法一定能在这个问题上找到最优解**。
*   例如：图的最小生成树（MST）问题符合拟阵性质，所以后期的 **Kruskal 算法** 和 **Prim 算法** 都是贪心算法。

---

## 6. C++ 实现：活动选择 (English Commented)

```cpp
#include <iostream>
#include <vector>
#include <algorithm>

using namespace std;

struct Activity {
    int id;
    int start;
    int finish;
};

// Sort activities by finish time (Greedy Choice Property)
bool compareFinish(Activity a, Activity b) {
    return a.finish < b.finish;
}

void activitySelection(vector<Activity>& acts) {
    // 1. Sort by finish time: O(n log n)
    sort(acts.begin(), acts.end(), compareFinish);

    cout << "--- Selected Activities ---" << endl;
    
    // 2. The first activity is always part of an optimal solution
    int n = acts.size();
    if (n == 0) return;

    cout << "Activity ID: " << acts[0].id << " (" << acts[0].start << ", " << acts[0].finish << ")" << endl;
    
    int lastFinish = acts[0].finish;

    // 3. Greedily pick the next compatible activity
    for (int i = 1; i < n; i++) {
        if (acts[i].start >= lastFinish) {
            cout << "Activity ID: " << acts[i].id << " (" << acts[i].start << ", " << acts[i].finish << ")" << endl;
            lastFinish = acts[i].finish;
        }
    }
}

int main() {
    vector<Activity> acts = {
        {1, 1, 4}, {2, 3, 5}, {3, 0, 6}, {4, 5, 7},
        {5, 3, 9}, {6, 5, 9}, {7, 6, 10}, {8, 8, 11},
        {9, 8, 12}, {10, 2, 14}, {11, 12, 16}
    };

    activitySelection(acts);
    return 0;
}
```

---

## 💡 助教的深度总结与感悟

1.  **贪心的快感**：
    学完 DP 再学贪心，你会有一种“如释重负”的感觉。DP 需要填一张复杂的表，而贪心只需要排个序，然后一个循环走到底。**这种降维打击的效率，是算法优化追求的极致。**

2.  **证明比实现更难**：
    写贪心算法代码只需 5 分钟，但证明这个贪心策略是对的可能需要 5 小时。大一自学时，建议多看书上的**替换证明法（Exchange Argument）**，这是理解贪心逻辑的精髓。

3.  **直觉与陷阱**：
    贪心算法非常依赖直觉，但直觉往往会骗人。例如：找零钱问题。
    *   如果是 [1, 5, 10, 25] 美分，贪心（每次给最大的）永远是对的。
    *   如果是 [1, 3, 4] 分，要找 6 分钱。贪心会给 [4, 1, 1]（三枚），但最优解是 [3, 3]（两枚）。
    *   **结论**：用贪心前，先问问自己：这个局部最优真的不会封死未来的路吗？

