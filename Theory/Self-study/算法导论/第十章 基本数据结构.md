# 第十章：基础数据结构

## 10.1 栈和队列 (Stacks and Queues)

这是两种最基本的“容器”，区别在于**删除操作**的顺序。

### 1. 栈 (Stack) —— 后进先出 (LIFO)
*   **天才的比喻**：就像食堂里叠在一起的托盘，你总是拿走最上面的，新洗好的托盘也放在最上面。
*   **操作**：
    *   `PUSH`：压入元素。
    *   `POP`：弹出最近压入的元素。
*   **注意**：要防止 **上溢 (Overflow)**（栈满还压）和 **下溢 (Underflow)**（栈空还弹）。

### 2. 队列 (Queue) —— 先进先出 (FIFO)
*   **天才的比喻**：就像排队买票，先来的先买，买完走人；后来的排在队尾。
*   **操作**：
    *   `ENQUEUE`：入队，加在队尾 (`tail`)。
    *   `DEQUEUE`：出队，从队头 (`head`) 取走。
*   **循环队列 (Circular Queue)**：为了不浪费数组空间，当 `tail` 或 `head` 到达数组末尾时，会绕回到下标 0。

---

## 10.2 链表 (Linked Lists)

**为何天才？** 数组需要连续的内存，而链表可以将散落在内存各处的“孤岛”通过**指针**连接成一条线。

*   **双向链表 (Doubly Linked List)**：每个节点除了数据，还有 `next` 指针指向后继，`prev` 指针指向前驱。
*   **哨兵节点 (Sentinel)**：这是 CLRS 中推荐的一个技巧。在链表头加一个“假节点”，可以简化插入和删除时的边界条件判断（不用再判断 `if (p->next == NULL)`）。

---

## 10.3 指针和对象的实现 (重要：底层思维)

这一节非常适合大一学生。它讨论了：**如果没有指针语言（如早期的 Fortran），如何用数组来模拟链表？**
*   **多数组表示法**：用 `next[i]`, `key[i]`, `prev[i]` 三个数组，下标 `i` 就充当了“地址”。
*   **自由表 (Free List)**：如何管理那些被删除的空位？将空位也连成一个链表，需要空间时从自由表取，删除时还给自由表。

---

## 10.4 有根树的表示 (Representing Rooted Trees)

### 1. 二叉树
*   每个节点存储：`left`, `right`, `parent`。

### 2. 分支无限的树 (左孩子右兄弟表示法)
**天才的想法**：如果你不知道一个节点有多少个孩子，难道要开辟无数个指针吗？
*   **方案**：每个节点只存两个指针：
    1.  `left-child`：指向它的**第一个**孩子。
    2.  `right-sibling`：指向它的**亲兄弟**。
*   **结论**：用这种方法，任何复杂的树都可以转化成二叉树的结构来存储！

---

## C 语言实现：栈与循环队列 (English Output)

这部分代码展示了如何处理“溢出”和“循环”逻辑。

```c
#include <stdio.h>
#include <stdbool.h>

#define MAX_SIZE 5

// --- 栈的实现 ---
typedef struct {
    int data[MAX_SIZE];
    int top;
} Stack;

void push(Stack *s, int x) {
    if (s->top >= MAX_SIZE - 1) {
        printf("Error: Stack overflow!\n"); // 栈溢出
        return;
    }
    s->data[++(s->top)] = x;
}

int pop(Stack *s) {
    if (s->top < 0) {
        printf("Error: Stack underflow!\n"); // 栈下溢
        return -1;
    }
    return s->data[(s->top)--];
}

// --- 循环队列的实现 ---
typedef struct {
    int data[MAX_SIZE];
    int head;
    int tail;
} Queue;

void enqueue(Queue *q, int x) {
    // 判断队满：tail 的下一个位置是 head
    if ((q->tail + 1) % MAX_SIZE == q->head) {
        printf("Error: Queue overflow!\n");
        return;
    }
    q->data[q->tail] = x;
    q->tail = (q->tail + 1) % MAX_SIZE; // 循环移动
}

int dequeue(Queue *q) {
    if (q->head == q->tail) {
        printf("Error: Queue underflow!\n");
        return -1;
    }
    int x = q->data[q->head];
    q->head = (q->head + 1) % MAX_SIZE; // 循环移动
    return x;
}

int main() {
    // 栈测试
    Stack s = {.top = -1};
    printf("--- Stack Test ---\n");
    push(&s, 10);
    push(&s, 20);
    printf("Popped: %d\n", pop(&s));
    printf("Popped: %d\n", pop(&s));
    pop(&s); // 触发下溢

    // 队列测试
    Queue q = {.head = 0, .tail = 0};
    printf("\n--- Queue Test ---\n");
    enqueue(&q, 100);
    enqueue(&q, 200);
    printf("Dequeued: %d\n", dequeue(&q));
    enqueue(&q, 300);
    enqueue(&q, 400);
    enqueue(&q, 500);
    enqueue(&q, 600); // 触发溢出（注意循环队列通常浪费一个空间来区分满和空）

    return 0;
}
```

---

## 💡 助教的深度感悟

1.  **关于数组 vs 链表**：
    *   数组是“静态”的，访问快（$O(1)$），但插入删除慢（$O(n)$）。
    *   链表是“动态”的，访问慢（$O(n)$），但如果你已经拿到了指针，插入删除极快（$O(1)$）。
    *   **感悟**：世界上没有完美的结构，只有最适合场景的权衡。

2.  **哨兵 (Sentinel) 的智慧**：
    *   刚开始学链表，最痛苦的就是处理 `if (head == NULL)` 或者 `if (node->next == NULL)`。
    *   **哨兵节点**通过牺牲一个存储空间，消除了所有 `NULL` 判断，让代码变得异常优雅。这是工程实践中非常重要的优化思维。

3.  **循环逻辑**：
    *   利用**取模运算 `%`** 实现循环，是计算机处理周期性任务的标准做法。
