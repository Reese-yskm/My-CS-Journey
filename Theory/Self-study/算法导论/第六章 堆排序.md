# 第六章 堆排序

欢迎来到第六章！如果说前四章让你领略了算法分析的“数学美”，那么从这一章开始，你将正式进入**算法与数据结构完美结合**的领域。

第六章介绍的是 **堆排序 (Heapsort)**。它非常精彩，因为它既有归并排序的效率（$O(n \lg n)$），又像插入排序一样节省空间（**原地排序**，不需要额外的辅助数组）。， +

---



## 堆

### 1. 什么是“堆” (The Heap)？

首先要区分一个概念：这里的“堆”是一种**数据结构**，指的是“二叉堆”。它和 Java/C++ 内存管理中的那个“堆区”没有任何关系。

*   **形象理解**：它是一棵“长得非常整齐”的树（近乎完全二叉树）。
*   **存储方式**：虽然逻辑上它是树，但物理上我们用**普通数组**来存它。这是堆最聪明的地方。

### 2. 数组如何变成一棵树？（下标规律）

在堆中，我们不需要像链表那样用指针（Left/Right 指针）。通过下标计算，我们就能找到任何节点的亲戚：

**假设数组下标从 1 开始（书中的伪代码习惯）：**
*   **根节点**：`A[1]`
*   **父节点 `PARENT(i)`**：`i / 2` (向下取整)
*   **左孩子 `LEFT(i)`**：`2 * i`
*   **右孩子 `RIGHT(i)`**：`2 * i + 1`

**💡 给大一学弟的 C 语言实现提示：**
C 语言数组是从 **0** 开始的。如果你用 C 语言写，公式会变成：
*   **左孩子**：`2*i + 1`
*   **右孩子**：`2*i + 2`
*   **父节点**：`(i-1) / 2`

**底层优化技巧：**
书中提到，在计算机底层，`2*i` 可以通过**左移一位 (`i << 1`)** 实现，`i/2` 可以通过**右移一位 (`i >> 1`)** 实现。这在追求极致性能的底层开发中非常常见。

---

### 3. 堆的两种形态

堆分为 **最大堆 (Max-Heap)** 和 **最小堆 (Min-Heap)**。

*   **最大堆性质**：`A[PARENT(i)] >= A[i]`
    *   **直观理解**：爸爸永远比儿子大。
    *   **结论**：整个数组最大的元素一定在根节点 `A[1]`。
    *   **用途**：用于 **堆排序**。
*   **最小堆性质**：`A[PARENT(i)] <= A[i]`
    *   **直观理解**：儿子永远比爸爸大。
    *   **结论**：最小的元素在根节点。
    *   **用途**：用于构造 **优先队列**（比如任务调度，优先级最高的先出）。

---

### 4. 堆的高度与性能

*   **堆的高度**：一个有 $n$ 个元素的堆，高度是 $\Theta(\lg n)$。
*   **为什么重要？** 因为堆的所有基本操作（调整、插入、删除）都只跟高度有关。这意味着这些操作的复杂度都是 **$O(\lg n)$**。

---

`MAX-HEAPIFY`（最大堆化）是整个堆排序算法的**心脏**。它的作用非常纯粹：**如果一个节点比它的儿子小，就让它“下沉”，直到它到了合适的位置。**

结合你提供的书稿（第 86-87 页），我为你总结了这一节的精华。

---



## 维护堆的性质

### 1. MAX-HEAPIFY 的前置条件（重要！）

在调用 `MAX-HEAPIFY(A, i)` 之前，算法假设了一个前提：
*   以 `LEFT(i)` 为根的子树已经是最大堆。
*   以 `RIGHT(i)` 为根的子树已经是最大堆。
*   **唯一的问题是**：`A[i]` 可能比它的儿子们小，破坏了规则。

所以，这个过程就像是**一个不称职的领导（A[i]）降临到了两个管理得非常完美的部门中间**，我们需要通过“逐级下调”让他去到该去的位置。

---

### 2. 伪代码逻辑拆解
这段伪代码虽然看起来有 10 行，但其实只做了三件事：

1.  **选出谁最大（1-7 行）：**
    在当前节点 `A[i]`、左孩子 `A[l]`、右孩子 `A[r]` 这三个数里，通过两次比较，把最大值的**下标**存在变量 `largest` 中。
2.  **判断是否需要交换（8-9 行）：**
    如果 `largest` 不等于 `i`，说明 `A[i]` 确实比孩子小。那就把 `A[i]` 和最大的那个孩子换位置。
3.  **递归下沉（10 行）：**
    交换之后，原来的“不称职领导” `A[i]` 到了新位置。但他在新位置可能还是比新的孩子小，所以要**递归**调用 `MAX-HEAPIFY` 继续往下比，直到他比孩子大或者变成了叶子节点。

---

### 3. 图 6-2 的直观演示
书里的例子非常经典：
*   **图(a)**：下标为 2 的元素是 **4**。它的两个孩子分别是 **14** 和 **7**。
*   **图(b)**：4 比 14 小，所以 4 和 14 交换。现在下标 2 变成了 14（合格了）。
*   **图(c)**：但是 4 到了下标 4 的位置后，发现它的孩子里有个 **8**。4 还是不够大，于是再次交换。
*   **结果**：4 最终沉到了叶子节点，整棵树恢复了最大堆性质。

---

### 4. 性能分析（为什么是 $O(\lg n)$？）
这是大一学生最需要掌握的理论点：

*   **最坏情况发生在哪？**
    当底层恰好半满时，一棵子树的规模最多是原树的 **2/3**（这是二叉树的几何特性决定的）。
*   **递归式**：$T(n) \le T(2n/3) + \Theta(1)$
*   **结果**：根据主定理，解为 **$O(\lg n)$**。
*   **直观理解**：一个高度为 $h$ 的堆，元素“下沉”的最长路径就是从根到叶子，路径长度就是 $h$。因为 $h = \lg n$，所以复杂度是 $O(\lg n)$。

---

## 优先队列

### 完整的堆与优先队列代码

```c
#include <stdio.h>
#include <stdlib.h>
#include <limits.h> // 为了使用 INT_MIN

// --- 核心工具：维护最大堆性质 (下沉) ---
void MAX_HEAPIFY(int *a, int n, int i)
{
    int left = 2 * i + 1;
    int right = 2 * i + 2;
    int largest = i;
    if (left < n && a[left] > a[i])
        largest = left;
    if (right < n && a[right] > a[largest])
        largest = right;
    
    if (largest != i)
    {
        int temp = a[i];
        a[i] = a[largest];
        a[largest] = temp;
        MAX_HEAPIFY(a, n, largest);
    }
}

// --- 核心工具：建堆 ---
void BUILD_MAX_HEAP(int *a, int n)
{
    for (int i = (n - 1) / 2; i >= 0; i--)
        MAX_HEAPIFY(a, n, i);
}

// --- 算法 1：堆排序 (会消耗掉堆) ---
void HEAPSORT(int *a, int n)
{
    BUILD_MAX_HEAP(a, n);
    for (int i = n - 1; i >= 1; i--)
    {
        int temp = a[0];
        a[0] = a[i];
        a[i] = temp;
        MAX_HEAPIFY(a, i, 0); // 剩余堆大小为 i
    }
}

// --- 优先队列操作 1：查看最大值 ---
int HEAP_MAXIMUM(int *a)
{
    return a[0];
}

// --- 优先队列操作 2：弹出最大值 (出队) ---
// 注意：这里使用 int *n 是因为出队后堆的大小会减 1
int HEAP_EXTRACT_MAX(int *a, int *n)
{
    if (*n < 1)
    {
        printf("错误：堆已空\n");
        return -1;
    }
    int max = a[0];
    a[0] = a[*n - 1]; // 把最后一个挪到根部
    (*n)--;           // 堆大小减 1
    MAX_HEAPIFY(a, *n, 0);
    return max;
}

// --- 优先队列操作 3：提升优先级 (上浮) ---
void HEAP_INCREASE_KEY(int *a, int i, int key)
{
    if (key < a[i])
    {
        printf("新值比旧值还小，无法提拔！\n");
        return;
    }
    a[i] = key;
    while (i > 0 && a[(i - 1) / 2] < a[i])
    {
        int temp = a[i];
        a[i] = a[(i - 1) / 2];
        a[(i - 1) / 2] = temp;
        i = (i - 1) / 2;
    }
}

// --- 优先队列操作 4：插入新元素 (入队) ---
void MAX_HEAP_INSERT(int *a, int *n, int key)
{
    (*n)++; // 堆大小加 1
    // 先放一个极小值，再用 INCREASE_KEY 提升它
    a[*n - 1] = INT_MIN; 
    HEAP_INCREASE_KEY(a, *n - 1, key);
}

// 打印当前堆状态的辅助函数
void print_array(int *a, int n) {
    for (int i = 0; i < n; i++) printf("%d ", a[i]);
    printf("\n");
}

// --- 测试主函数 ---
int main(void)
{
    // 测试 1：堆排序
    int data[7] = {3, 5, 2, 1, 4, 7, 6};
    int n = 7;
    printf("--- 1. 堆排序测试 ---\n");
    printf("原始数组: "); print_array(data, n);
    HEAPSORT(data, n);
    printf("排序后:   "); print_array(data, n);
    printf("\n");

    // 测试 2：优先队列动态操作
    printf("--- 2. 优先队列测试 ---\n");
    int heap[100]; // 预留足够空间
    int heap_size = 0;

    printf("依次插入任务，优先级为: 10, 20, 5, 15\n");
    MAX_HEAP_INSERT(heap, &heap_size, 10);
    MAX_HEAP_INSERT(heap, &heap_size, 20);
    MAX_HEAP_INSERT(heap, &heap_size, 5);
    MAX_HEAP_INSERT(heap, &heap_size, 15);
    printf("当前堆状态: "); print_array(heap, heap_size);

    printf("取出当前最高优先级任务: %d\n", HEAP_EXTRACT_MAX(heap, &heap_size));
    printf("取出后堆状态: "); print_array(heap, heap_size);

    printf("现在将下标为 2 的元素(值为 %d) 优先级提升至 30\n", heap[2]);
    HEAP_INCREASE_KEY(heap, 2, 30);
    printf("提升后堆状态: "); print_array(heap, heap_size);

    printf("再次取出最高优先级任务: %d\n", HEAP_EXTRACT_MAX(heap, &heap_size));
    printf("最终堆状态: "); print_array(heap, heap_size);

    return 0;
}
```

### 💡 助教的深度讲解（帮你巩固）：

1.  **为什么 `INSERT` 要先赋 `INT_MIN` 再调用 `INCREASE_KEY`？**
    虽然你可以直接把新值放在末尾然后写个循环上浮，但《算法导论》这样写是为了**代码复用**。既然我们已经写好了功能强大的 `INCREASE_KEY`，那插入一个新值就可以看作是“增加一个极小值，然后把它提升到目标值”。这在软件工程里叫**减少冗余**。

2.  **指针传递 `&heap_size` 的必要性**：
    在 `HEAPSORT` 里，我们不需要修改 `main` 里的数组长度。但在优先队列里，如果我们不把 `heap_size` 的地址传进去，函数里修改的只是一个副本，`main` 函数里的 `heap_size` 还是旧值，这样下一次插入时就会覆盖掉之前的数据。这是大一 C 语言课最爱考的**地址传递 vs 值传递**。

3.  **这个算法的威力**：
    你现在写的这段代码，其实就是很多高性能中间件（如任务队列、定时器）的基础。以后你学到操作系统、网络编程，凡是涉及“挑出最紧急的事情去处理”的情况，你脑子里跳出来的第一反应就应该是你写的这个**堆**。

**至此，第六章你已经通关了！**
你感觉如何？如果觉得这套“下沉与上浮”的逻辑已经形成了肌肉记忆，那我们可以准备翻开第七章——**快速排序 (Quicksort)**。那是一个虽然平均性能更好，但需要你理解“分区 (Partition)”艺术的新领域。