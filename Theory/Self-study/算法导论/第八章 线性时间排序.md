# 第八章：线性时间排序

## 8.1 决策树模型：为什么 $n \lg n$ 是“天花板”？

**天才的想法**：把排序过程想象成一棵**决策树**。
*   每一个节点都是一次 `if (a[i] <= a[j])`。
*   每一条从根到叶子的路径，都对应一种可能的排序结果。
*   **数学证明**：$n$ 个元素有 $n!$ 种排列方式，所以决策树至少要有 $n!$ 个叶子节点。一棵高度为 $h$ 的二叉树最多有 $2^h$ 个叶子。
    *   得出方程：$2^h \ge n!$
    *   解出 $h \ge \lg(n!) \approx n \lg n$。
*   **结论**：**堆排序**和**归并排序**在理论上已经达到了比较排序的极致，不可能有更好的比较排序算法了。

---

## 8.2 计数排序 (Counting Sort) —— 降维打击

**天才的想法**：不再通过“比大小”来定位置，而是直接**数你有几个小弟**。如果你发现比你小的数有 5 个，那你在排好序的数组里直接坐第 6 把交椅。

*   **适用前提**：输入的数必须是落在 $[0, k]$ 范围内的整数。
*   **时间复杂度**：$O(n + k)$。如果 $k = O(n)$，它就是纯粹的 **$O(n)$**。
*   **稳定性**：**至关重要！** 计数排序是稳定的。这意味着如果有两个 5，排完序后原先在前面的那个 5 依然在前面。

### C 语言实现 (English Output)

```c
#include <stdio.h>
#include <stdlib.h>

// Counting Sort: 假设数组元素在 0 到 k 之间
void counting_sort(int *a, int n, int k) {
    int *c = (int *)calloc(k + 1, sizeof(int)); // 计数数组
    int *b = (int *)malloc(n * sizeof(int));     // 临时存储结果

    // 1. 统计每个元素出现的次数
    for (int j = 0; j < n; j++) {
        c[a[j]]++;
    }

    // 2. 累加：确定每个元素的最终位置
    for (int i = 1; i <= k; i++) {
        c[i] = c[i] + c[i - 1];
    }

    // 3. 反向填充（为了保证稳定性）：将元素放到正确位置
    for (int j = n - 1; j >= 0; j--) {
        b[c[a[j]] - 1] = a[j];
        c[a[j]]--;
    }

    // 4. 写回原数组
    for (int i = 0; i < n; i++) {
        a[i] = b[i];
    }

    free(c);
    free(b);
}

int main() {
    int data[] = {2, 5, 3, 0, 2, 3, 0, 3};
    int n = sizeof(data) / sizeof(data[0]);
    
    printf("--- Counting Sort Test ---\n");
    counting_sort(data, n, 5); // 最大值为 5
    
    printf("Sorted array: ");
    for (int i = 0; i < n; i++) printf("%d ", data[i]);
    printf("\n");
    return 0;
}
```

---

## 8.3 基数排序 (Radix Sort) —— 剥洋葱的智慧

**天才的想法**：如果要排很大的数（比如手机号），不需要直接数几百亿。我们先按**个位**排，再按**十位**排……一直排到最高位。

*   **核心要求**：每一位的排序必须是**稳定**的（通常用计数排序作为子过程）。
*   **为什么从低位到高位（LSD）？** 因为这样高位的排序会覆盖低位的“微调”，但由于稳定性，低位的相对顺序在相同高位时会得以保留。

---

## 8.4 桶排序 (Bucket Sort) —— 空间换时间的极致

**天才的想法**：将 $[0, 1)$ 这种区间均匀划分成若干个“桶”。把数扔进对应的桶里，由于数据是均匀分布的，每个桶里的数很少，再用插入排序处理每个桶。

*   **复杂度**：期望运行时间为 $O(n)$。
*   **适用场景**：数据分布非常**均匀**。

---

## 总结：排序算法大礼包

| 算法         | 平均时间     | 空间       | 稳定性   | 备注             |
| :----------- | :----------- | :--------- | :------- | :--------------- |
| **快速排序** | $O(n \lg n)$ | $O(\lg n)$ | 不稳定   | 工业界最常用     |
| **堆排序**   | $O(n \lg n)$ | $O(1)$     | 不稳定   | 空间利用率最高   |
| **归并排序** | $O(n \lg n)$ | $O(n)$     | **稳定** | 外部排序常用     |
| **计数排序** | $O(n+k)$     | $O(n+k)$   | **稳定** | 必须是小范围整数 |

---

### 💡 大一学弟的“避坑”感悟

1.  **关于“稳定性”**：以前我觉得“排好就行，管它谁在前”。但学到基数排序我才发现，如果不稳定，基数排序根本跑不通。**稳定性是算法的“记忆力”。**
2.  **没有最强的算法**：快排虽然快，但在排“学生成绩（0-100分）”这种数据时，它会被计数排序虐得体无完肤。**算法的强弱取决于你对数据的了解程度。**
3.  **空间换时间**：计数排序为了达到 $O(n)$，开辟了额外的计数数组。在计算机世界里，如果你想赢过时间，往往得拿空间去换。
