# 《算法导论》第十三章：红黑树全章笔记

## 1. 红黑树的本质与定义
红黑树是一种**自平衡**的二叉搜索树。它保证没有任何一条路径会比其他路径长出两倍，因此在最坏情况下，基本动态集合操作的时间复杂度均为 **$O(\lg n)$**。

### 红黑性质（五条天条）：
1.  **每个节点或者是红色的，或者是黑色的。**
2.  **根节点是黑色的。**
3.  **每个叶节点（NIL）是黑色的。**
4.  **如果一个节点是红色的，则它的两个子节点都是黑色的。**（不能有两个连续的红节点）
5.  **对每个节点，从该节点到其所有后代叶节点的简单路径上，均包含相同数目的黑色节点。**（黑高相等）

---

## 2. 哨兵节点 (Sentinel `T.nil`)

在写代码实现时，如果给每个叶子都弄一个真实的 NULL 节点，太浪费空间且容易写错。

* **天才的想法**：用一个统一的哨兵对象 `T.nil` 来代表所有的叶节点
* **属性**：它的 color 是 **BLACK**，其他属性（key, left, right）可以设为任意值。
* **好处**：这大大简化了插入和删除时的边界判断。你可以像对待普通节点一样对待 `T.nil`，不用每次都判断 `if (x != NULL)`。

## 3. 旋转（Rotations）：结构调整的原子操作

当我们在红黑树中进行插入或删除时，性质可能会被破坏。**旋转**是用来修复性质且保持 BST 性质（左小右大）的手段。

### 左旋 (Left-Rotate) 与 右旋 (Right-Rotate)
*   **左旋逻辑**：将节点 $x$ 向左下移动，让它的右孩子 $y$ 变成新的根，同时 $y$ 的左子树变成 $x$ 的右子树。
*   **特性**：旋转操作在 **$O(1)$** 时间内完成，且**不改变中序遍历的结果**。

**C++ 代码实现（左旋）：**
```cpp
void left_rotate(Node* &root, Node* x, Node* nil) {
    Node* y = x->right;         // 设置 y
    x->right = y->left;         // 将 y 的左子树转为 x 的右子树
    if (y->left != nil)
        y->left->p = x;
    y->p = x->p;                // 将 x 的父节点连到 y 上
    if (x->p == nil)
        root = y;
    else if (x == x->p->left)
        x->p->left = y;
    else
        x->p->right = y;
    y->left = x;                // 把 x 放回 y 的左边
    x->p = y;
}
```

---

## 4. 插入 (Insertion)
插入一个新节点分为两步：
1.  **按 BST 逻辑插入**：将新节点设为**红色**（为了不破坏黑高性质 5）。
2.  **修复 (RB-INSERT-FIXUP)**：如果新节点的父亲也是红色，违反了性质 4，则需要通过变色和旋转来修复。

### 插入修复的三种情况（核心在于看“叔叔”的颜色）：
*   **Case 1**：叔叔节点是红色的。
    *   *动作*：爷爷变红，爸爸和叔叔变黑，然后从爷爷向上递归。
*   **Case 2**：叔叔是黑色的，且当前节点是右孩子（折线型）。
    *   *动作*：对爸爸进行左旋，转成 Case 3。
*   **Case 3**：叔叔是黑色的，且当前节点是左孩子（直线型）。
    *   *动作*：爸爸变黑，爷爷变红，对爷爷进行右旋。

---

## 5. 删除 (Deletion) —— 最终挑战
删除比插入复杂得多。基本逻辑是：
1.  执行标准的 BST 删除。
2.  如果被删除或移走的节点是**黑色**，会破坏性质 5（黑高减少）或性质 2（根变红），需要通过 **RB-DELETE-FIXUP** 修复。

### 删除修复的四个情况：
此时核心在于看**兄弟节点**的颜色和它孩子的颜色。通过 4 种情况的变换，最终补齐缺失的那个黑高。

---

## 6. 💡 助教的深度总结与感悟

### 为什么红黑树比普通 BST 强大？
*   **稳定的效率**：在实际应用中，数据往往不是完全随机的。如果数据是接近有序的，普通 BST 会非常慢，而红黑树通过强制性的“五条性质”，保证了无论数据多烂，它都能在大约 $2\lg n$ 的高度内完成任务。

### 为什么是红色和黑色？
*   其实颜色只是一个标记。红黑树的本质是模拟 **2-3-4 树**。红色节点可以看作是与其父节点合并在一起形成一个大的节点。通过颜色，我们用二叉树的形式实现了一棵极其平衡的多路搜索树。

### 自学心得建议：
1.  **不必死磕删除的代码细节**：在大一阶段，理解红黑树的 5 条性质以及**“为什么旋转和变色能恢复平衡”**的直觉，比背下删除的 4 种情况更重要。
2.  **重视 NIL 哨兵**：写红黑树代码时，一定要用一个固定的 `T.nil` 对象。否则处理 `x->p->p` 这种父节点的父节点时，频繁的 `NULL` 判断会让你崩溃。
3.  **对比学习**：学完红黑树后，你可以搜一下 **AVL 树**。AVL 树追求绝对平衡（左右高度差不超过1），而红黑树追求相对平衡。红黑树的插入和删除旋转次数更少，因此在频繁变动的数据集中性能更好。

---

**学到这里，你已经站在了初级数据结构的顶峰！**

第 10、11、12、13 章构成了计算机科学中最核心的“动态集合”理论。

**接下来，第十四章是对红黑树的扩展（比如：如何在一棵树里快速算出某个数的排名），或者是你可以选择跳过第十四章，直接进入第五部分：高级设计与分析（动态规划、贪心算法）。**

**你是想看看红黑树还能怎么玩（扩展），还是去学习面试和竞赛中最核心的“动态规划”？**