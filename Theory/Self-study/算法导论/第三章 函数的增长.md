# 第三章 函数的增长



##  渐进记号

### 一、 核心概念：三个“界”

书中给出的数学定义可能看着头晕，我们用更直观的方式来理解：

#### 1. $O$ 记号（最坏情况的保障 - 上界）
*   **直观理解：** “运行时间**不会超过**这个量级”。
*   **数学逻辑：** $f(n) = O(g(n))$ 意味着 $f$ 的增长速度比 $g$ 慢或者一样快。
*   **例子：** 插入排序的最坏运行时间是 $O(n^2)$。即使你给它最乱的数组，它顶多也就是 $n^2$ 的速度，不会变成 $n^3$。
*   **注意：** $O$ 是可以“吹牛”的。如果你说插入排序是 $O(n^3)$，数学上也是正确的，只是不够**紧确**。

#### 2. $\Omega$ 记号（最好情况的保障 - 下界）
*   **直观理解：** “运行时间**至少要**这么多”。
*   **数学逻辑：** $f(n) = \Omega(g(n))$ 意味着 $f$ 的增长速度比 $g$ 快或者一样快。
*   **例子：** 插入排序的最好情况是数组已经排好序，只需扫描一遍，所以它是 $\Omega(n)$。

#### 3. $\Theta$ 记号（精确的描述 - 紧确界）
*   **直观理解：** “运行时间**刚好就是**这个量级”。
*   **数学逻辑：** 当一个函数既是 $O(g(n))$ 又是 $\Omega(g(n))$ 时，它就是 $\Theta(g(n))$。
*   **形象比喻：** 就像夹心饼干，函数 $f(n)$ 被夹在 $c_1 g(n)$ 和 $c_2 g(n)$ 中间。

---

### 二、 如何在分析代码时应用这些记号？

分析运行时间时，你可以遵循**“忽略低阶项，忽略常数项”**的原则。

#### 实例 1：单层循环（线性查找）
```c
for (int i = 0; i < n; i++) {
    if (a[i] == x) return i;
}
```
*   **分析：** 
    *   **最坏情况：** 找遍 $n$ 个元素才找到或没找到。时间是 $c \cdot n$。记作 **$O(n)$**。
    *   **最好情况：** 第一个就是。时间是常数 $c$。记作 **$\Omega(1)$**。
    *   **注意：** 因为最好和最坏不一样，所以我们不能说整个算法是 $\Theta(n)$，只能分情况说。

#### 实例 2：双层嵌套循环（简单的冒泡或插入排序）
```c
for (int i = 0; i < n; i++) {        // 执行 n 次
    for (int j = 0; j < n; j++) {    // 每一次 i 对应执行 n 次
        count++;                      // 常数操作
    }
}
```
*   **分析：** 总操作次数大约是 $n \times n = n^2$。
*   **记号：** **$\Theta(n^2)$**。不管数组长啥样，这两层死循环都会跑满，所以它的上界和下界是一样的，用 $\Theta$ 最准确。

#### 实例 3：分治法（归并排序）
你在上一章写的归并排序，它的递归式是 $T(n) = 2T(n/2) + \Theta(n)$。
*   **分析：** 每次把问题切一半（$\log n$ 层），每一层合并的代价是 $n$。
*   **记号：** **$\Theta(n \log n)$**。

---

### 三、 书中那个 $1/2 n^2 - 3n = \Theta(n^2)$ 的数学证明怎么看？

图片中（第26页）花了很大篇幅证明这个。大一学生容易卡在这里，其实你只需要理解它的**目的**：

它是想证明，当 $n$ 变得非常大时：
1.  $-3n$ 变得微不足道。
2.  $1/2$ 这个常数系数也不重要。
3.  **只要你能找到两个常数（比如 $c_1=1/14, c_2=1/2$）和一起跑点 $n_0=7$，使得 $c_1 n^2 \le 1/2 n^2 - 3n \le c_2 n^2$ 成立，这个结论就成立。**

**结论：** 在算法的世界里，我们只看最高权力的那个“王”。$n^2$ 就是王，其他的都是随从。

---

### 四、 给大一新生的“防坑”笔记

1.  **$O(1)$ 是什么？**
    $O(1)$ 并不代表只有 1 次操作，而是代表操作次数是一个**常数**，不随输入规模 $n$ 的增大而增大。比如：`int a = 10000 + 20000;` 依然是 $O(1)$。

2.  **为什么不写底数？**
    在算法分析中，我们写 $O(\log n)$ 而不是 $O(\log_2 n)$。因为根据换底公式，不同底数的对数只差一个常数倍，而渐进分析会忽略常数。

3.  **$O(n^2)$ 一定比 $O(n)$ 慢吗？**
    **不一定！** 在 $n$ 很小的时候（比如 $n=2$），$n^2$ 的算法可能因为常数项小而比 $n$ 的算法快。渐进分析关心的是 **“当 $n$ 趋向无穷大”** 时的表现。

---

### 五、 渐进记号作为“匿名函数”（最实用的部分）

在复杂的公式里，我们经常看到 $2n^2 + 3n + 1 = 2n^2 + \Theta(n)$。

*   **为什么要这么写？**
    为了**偷懒**（其实是简化）。我们并不关心 $3n+1$ 到底长什么样，我们只关心它的量级。
*   **如何理解？**
    你可以把 $\Theta(n)$ 看作一个**没有名字的函数**（匿名函数）。
    公式左边的 $3n+1$ 就是这个匿名函数的一个具体实例。
*   **等号的非对称性（大一学生容易困惑点）：**
    在算法导论里，这个等号 $=$ 并不代表“左右完全相等”，而应该读作**“属于”**或**“包含于”**。
    *   你可以写 $2n^2 + \Theta(n) = \Theta(n^2)$。
    *   但你**绝对不能**反过来写 $\Theta(n^2) = 2n^2 + \Theta(n)$。
    *   **直观理解：** 粗糙的描述（右边）可以涵盖精细的描述（左边），但反之不行。就像“你是人”是对的，但“人是你”是错的。

---

### 六、 $o$（小 o）与 $\omega$（小 $\omega$）：从“不大于”到“小于”

这是对 $O$ 和 $\Omega$ 的进一步精确化，区别在于**是否包含“相等”的可能性**。

| 记号               | 类比实数关系 | 直观解释               | 数学极限定义 ($n \to \infty$)            |
| :----------------- | :----------- | :--------------------- | :--------------------------------------- |
| **$O(g(n))$**      | $\le$        | $f$ 增长不快于 $g$     | $\lim \frac{f(n)}{g(n)} < \infty$ (常数) |
| **$o(g(n))$**      | $<$          | $f$ 增长**远慢于** $g$ | $\lim \frac{f(n)}{g(n)} = 0$             |
| **$\Omega(g(n))$** | $\ge$        | $f$ 增长不慢于 $g$     | $\lim \frac{f(n)}{g(n)} > 0$             |
| **$\omega(g(n))$** | $>$          | $f$ 增长**远快于** $g$ | $\lim \frac{f(n)}{g(n)} = \infty$        |

*   **例子：**
    *   $2n = O(n)$ 是对的（因为 $2n$ 和 $n$ 量级相同）。
    *   $2n = o(n)$ 是**错的**（因为它们量级相同，没有“远慢于”）。
    *   $2n = o(n^2)$ 是对的。

---

### 7、 函数比较的性质：算法界的“实数类比”

书中第 30 页把渐进记号和实数的大小比较做了非常完美的类比。这是为了让你在证明算法复杂度时，可以像做初中代数一样进行**传递**。

*   **传递性：** 如果 $f = O(g)$ 且 $g = O(h)$，那么 $f = O(h)$。这是最常用的性质。
*   **自反性：** $f = O(f)$（任何函数都是它自己的上界）。
*   **转置对称性：** $f(n) = O(g(n))$ 相当于 $g(n) = \Omega(f(n))$。

#### **关键的区别：三分性 (Trichotomy) 不成立**
这是考试或面试中偶尔会考到的细节：
*   **实数：** 任意两个数 $a, b$，要么 $a<b$，要么 $a>b$，要么 $a=b$。
*   **算法函数：** 并不是任意两个函数都能比较大小！
    *   **例子：** $n$ 和 $n^{1+\sin n}$。
    *   由于 $\sin n$ 在 $-1$ 到 $1$ 之间来回摆动，$n^{1+\sin n}$ 的量级一会儿比 $n$ 大，一会儿比 $n$ 小。这两个函数**无法比较渐进大小**。



## 标准记号与常用函数

