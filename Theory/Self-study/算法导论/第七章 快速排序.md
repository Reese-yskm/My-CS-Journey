# 第七章：快速排序 (Hoare 分区版) 学习笔记

## 1. 核心直觉：双指针碰撞 (Two-Pointer Collision)
相比于书上“单向扫描”的逻辑，你写的这个“双向扫描”逻辑更具对称美：
*   **Pivot (基准)**：选中间的元素 `a[q]`。
*   **指针 `i`**：从左往右找，直到发现一个**不该**在左边的大元素（$\ge$ 基准）。
*   **指针 `j`**：从右往左找，直到发现一个**不该**在右边的小元素（$\le$ 基准）。
*   **交换**：既然两个人都站错了队，那就互换位置，然后继续走。

---

## 2. 为什么这个版本更“天才”？
1.  **交换次数更少**：只有当 `i` 和 `j` 都找到了“坏分子”才交换，不像 Lomuto 分区那样只要看到小的就交换。
2.  **处理重复元素极其优秀**：如果数组里全是相同的数字（如 `[1, 1, 1, 1]`），你写的 `do-while` 会让 `i` 和 `j` 在中间相遇，从而完美平分数组。而书上的版本会产生极度不均匀的分割，导致 $O(n^2)$。
3.  **缓存友好**：它从两头往中间走，符合内存预取的特性。

---

## 3. 细节里的“魔鬼”（容易出错的地方）

快排的代码看起来简单，但下标极易出错。你的实现非常稳健，有几个点我们要记在笔记里：

*   **指针初始化**：`i = l - 1` 和 `j = r + 1`。
    *   **原因**：因为使用的是 `do...while` 循环，进循环先执行 `i++` 或 `j--`。这样能保证第一次比较的是真正的第一个和最后一个元素。
*   **递归边界**：`quick_sort(l, j)` 和 `quick_sort(j + 1, r)`。
    *   **警告**：当你使用 `j` 作为分割点时，基准 `q` **绝对不能**选最右边的元素（`a[r]`），否则在只有两个元素且有序时会陷入死循环。你选的是 `l + (r - l) / 2`（中间值），这非常安全！
*   **停止条件**：`while (a[i] < a[q])`。
    *   **注意**：这里不能写成 `a[i] <= a[q]`。写成严格小于，可以保证当遇到等于基准的元素时，指针停下来进行交换，从而维持平衡。

---

## 4. 完整的代码实现与测试 (English Output)

按照我们的约定，代码输出英文，注释中文：

```c
#include <stdio.h>

// 交换辅助函数
void swap(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

// 快速排序 (Hoare 分区变种)
void quick_sort(int *a, int l, int r)
{
    // 递归终点
    if (l >= r) return;

    // 选择中间位置的值作为基准，防止在有序数组上退化
    int pivot = a[l + (r - l) / 2];
    int i = l - 1;
    int j = r + 1;

    while (i < j)
    {
        // 从左往右找第一个大于等于 pivot 的数
        do { i++; } while (a[i] < pivot);
        // 从右往左找第一个小于等于 pivot 的数
        do { j--; } while (a[j] > pivot);
        
        // 如果指针没相遇，交换这两个数
        if (i < j) swap(&a[i], &a[j]);
    }

    // 递归处理左右两个子区间
    // 注意：j 之后是 j+1，这是 Hoare 分区的标准分割方式
    quick_sort(a, l, j);
    quick_sort(a, j + 1, r);
}

// 辅助打印函数
void print_array(int *a, int n) {
    for (int i = 0; i < n; i++) printf("%d ", a[i]);
    printf("\n");
}

int main(void)
{
    int data[] = {49, 38, 65, 97, 76, 13, 27, 49};
    int n = sizeof(data) / sizeof(data[0]);

    printf("--- Quick Sort (Hoare Partition) Test ---\n");
    printf("Before sorting: ");
    print_array(data, n);

    quick_sort(data, 0, n - 1);

    printf("After sorting:  ");
    print_array(data, n);

    return 0;
}
```

