# 《算法导论》第九章：中位数和顺序统计量

## 9.1 最小值和最大值 (Minimum and Maximum)

找到一个 $n$ 元素的最小值，最直观的方法是比较 $n-1$ 次。这已经是最优的了。

### 天才的想法：同时找最大值和最小值
如果你分别找最大值和最小值，需要 $(n-1) + (n-1) = 2n-2$ 次比较。
**但是，我们可以只用约 $3n/2$ 次比较就同时搞定。**

*   **策略：** 不要一个一个和当前 `min/max` 比，而是**成对（Pair）**处理。
    1.  取两个数 $a, b$，先让它们俩比一下。
    2.  大的那个去跟当前 `max` 比。
    3.  小的那个去跟当前 `min` 比。
*   **代价：** 每 2 个元素只需要 3 次比较，而不是 4 次。
*   **结论：** 总比较次数最多为 $3\lfloor n/2 \rfloor$ 次。这种“成对处理”的思维在很多底层优化中非常常见。

---

## 9.2 期望时间为 $O(n)$ 的选择算法 (Randomized Select)

这个算法是基于**快速排序**的 `PARTITION` 过程改进的。

*   **逻辑：**
    1.  执行一次随机划分（Randomized Partition），得到基准点 $q$ 的排名 $k$。
    2.  如果我们要找的 $i == k$，直接返回结果。
    3.  如果 $i < k$，说明目标在左半边，我们**只递归左边**。
    4.  如果 $i > k$，说明目标在右半边，我们**只递归右边**。

### 为什么它很快？
*   **快速排序**：每次都要递归两边，所以是 $O(n \lg n)$。
*   **快速选择**：每次只走一边。
*   **数学直觉**：工作量就像 $n + n/2 + n/4 + \dots \approx 2n$。
*   **时间复杂度**：期望时间是 **$O(n)$**，最坏情况（每次都切得很偏）是 $O(n^2)$。

---

## 9.3 最坏情况为 $O(n)$ 的选择算法 (Median of Medians)

这是本章最硬核的内容。为了防止快排切分不均导致的 $O(n^2)$，科学家们设计了一个极其精妙的办法来寻找“绝对稳健”的基准点——**中位数的中位数（Median of Medians）**。

### 五步走策略 (The SELECT Algorithm)：
1.  **分组**：将 $n$ 个元素分成 $\lceil n/5 \rceil$ 组，每组 5 个元素。
2.  **找中位数**：用插入排序找到每组的中位数。
3.  **递归找基准**：对这 $n/5$ 个中位数再次调用 `SELECT`，找到它们的**中位数 $x$**。
4.  **划分**：以 $x$ 为基准进行 `PARTITION`。
5.  **判断并递归**：同 9.2 节。

### 为什么选“5”？
这是一个经过精密计算的常数。通过递归式 $T(n) \le T(n/5) + T(7n/10 + 6) + O(n)$，可以证明其解依然是 **$O(n)$**。
这个算法在理论上很美，但在实际工程中由于常数项过大，通常还是倾向于使用 9.2 节的随机化版本。

---

## 代码实现：Randomized Select (C 语言)

这是最实用的版本，我为你加上了测试逻辑。

```c
#include <stdio.h>
#include <stdlib.h>
#include <time.h>

// 交换函数
void swap(int *x, int *y) {
    int temp = *x;
    *x = *y;
    *y = temp;
}

// 标准分区函数 (Lomuto 分区)
int partition(int *a, int low, int high) {
    int pivot = a[high];
    int i = low - 1;
    for (int j = low; j < high; j++) {
        if (a[j] <= pivot) {
            i++;
            swap(&a[i], &a[j]);
        }
    }
    swap(&a[i + 1], &a[high]);
    return i + 1;
}

// 随机分区函数：防止最坏情况
int randomized_partition(int *a, int low, int high) {
    int i = low + rand() % (high - low + 1);
    swap(&a[i], &a[high]);
    return partition(a, low, high);
}

// 核心函数：找到第 k 小的元素 (k 从 0 开始)
int randomized_select(int *a, int p, int r, int i) {
    if (p == r) return a[p];

    // 划分并获取基准的排名
    int q = randomized_partition(a, p, r);
    int k = q - p; // 基准左侧元素个数

    if (i == k) {
        return a[q]; // 找到了
    } else if (i < k) {
        // 在左侧查找
        return randomized_select(a, p, q - 1, i);
    } else {
        // 在右侧查找，注意修正目标排名
        return randomized_select(a, q + 1, r, i - k - 1);
    }
}

int main(void) {
    srand(time(NULL)); // 初始化随机种子

    int data[] = {3, 2, 9, 0, 7, 5, 4, 8, 6, 1};
    int n = sizeof(data) / sizeof(data[0]);
    
    // 假设我们要找第 4 小的数 (即下标为 3)
    int target_rank = 3; 

    printf("--- Randomized Select Test ---\n");
    printf("Original array: ");
    for(int j=0; j<n; j++) printf("%d ", data[j]);
    printf("\n");

    int result = randomized_select(data, 0, n - 1, target_rank);

    printf("The element with rank %d is: %d\n", target_rank, result);

    return 0;
}
```

---

## 💡 助教的深度感悟

1.  **分治的变体**：
    *   **归并排序/快速排序**：分而治之，最后“合”。
    *   **选择算法**：分而治之，但每次**剪枝（Pruning）**。你只需要关注目标所在的那个分支，这种思路在搜索算法中极其重要。

2.  **概率的力量**：
    *   在第九章你会深刻体会到，为什么“随机化”在算法中如此重要。仅仅通过随机选一个基准点，就能把 $O(n^2)$ 的最坏情况在概率上压缩到几乎不可能发生。

3.  **理论与实践的平衡**：
    *   “中位数的中位数”算法（9.3节）证明了人类智力的极限——我们可以确保最坏也是线性。但在真实世界的计算机里，简单的随机化往往跑得更顺滑。
