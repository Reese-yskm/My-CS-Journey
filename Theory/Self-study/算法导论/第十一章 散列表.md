# 第十一章：散列表 (Hash Tables)

## 1. 核心矛盾：空间 vs 时间

*   **直接寻址表 (Direct Addressing)**：如果你要存 0-99 的数，直接开个长度 100 的数组。查找是 $O(1)$，太快了！但如果你要存身份证号（18位），开个那么大的数组，地球的内存都不够用。
*   **散列表的天才想法**：我们要存的关键字集合 $K$ 很大，但实际存进去的元素个数 $n$ 很小。
    *   **方案**：建立一个长度为 $m$ 的较小数组（槽），通过 **散列函数 (Hash Function) $h(k)$**，把巨大的关键字 $k$ 映射到 $[0, m-1]$ 的小空间里。

---

## 2. 散列函数：如何分配座位？

一个好的散列函数应该让关键字“均匀”地分布在数组里。

1.  **除法散列法 (Division Method)**：最常用。
    *   公式：**$h(k) = k \mod m$**
    *   **诀窍**：$m$（数组大小）最好选一个**不接近 2 的幂的质数**，这样能减少冲突。
2.  **乘法散列法 (Multiplication Method)**：
    *   公式：$h(k) = \lfloor m(kA \mod 1) \rfloor$。
    *   优点：对 $m$ 的选择不敏感。

---

## 3. 冲突处理：如果两个人撞座了怎么办？ (Collisions)

这是本章的重难点。因为数组比关键字空间小，必然会有 $h(k_1) = h(k_2)$。

### 方案 A：链接法 (Chaining) —— 工业界的主流
*   **想法**：数组的每个位置不存数据，而是存一个**链表的头指针**。
*   **操作**：撞座了？那就挂在同一个下标的链表后面。
*   **复杂度**：最坏 $O(n)$（全撞在一起），但平均是 **$O(1)$**。

### 方案 B：开放寻址法 (Open Addressing)
*   **想法**：不准用链表，所有人都必须坐在数组里。
*   **操作**：如果我的位置被占了，我就按某种规则找下一个空位。
    *   **线性探测 (Linear Probing)**：挨个往后找。容易产生“堆积”现象（一大片连续位置被占）。
    *   **双重散列 (Double Hashing)**：如果撞了，用第二个哈希函数计算步长。

---

## 4. 代码实现：哈希表（链接法）

这是最经典的实现方式。我们用英语输出，中文注释。

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define BUCKET_COUNT 10 // 为了方便观察冲突，我们把数组开小一点

// 1. 定义存储节点
typedef struct Node {
    int key;            // 键
    int value;          // 值（比如学生学号对应的成绩）
    struct Node* next;  // 指向冲突的下一个节点
} Node;

// 2. 定义哈希表主体
typedef struct {
    Node* buckets[BUCKET_COUNT]; // 桶数组，每个元素是一个链表头指针
} HashTable;

// 3. 简单的哈希函数 (除法取余法)
int hash(int key) {
    return key % BUCKET_COUNT;
}

// 4. 插入操作 (Insert)
void hash_table_insert(HashTable* ht, int key, int value) {
    int index = hash(key);
    
    // 创建新节点
    Node* newNode = (Node*)malloc(sizeof(Node));
    newNode->key = key;
    newNode->value = value;
    
    // 采用“头插法”：新节点指向当前的头，然后新节点变成新的头 (O(1)操作)
    newNode->next = ht->buckets[index];
    ht->buckets[index] = newNode;
    
    printf("Inserted: Key %d -> Value %d at Index %d\n", key, value, index);
}

// 5. 查找操作 (Search)
int hash_table_search(HashTable* ht, int key) {
    int index = hash(key);
    Node* current = ht->buckets[index];
    
    // 在对应的链表中遍历
    while (current != NULL) {
        if (current->key == key) {
            return current->value; // 找到了，返回对应的值
        }
        current = current->next;
    }
    return -1; // 代表没找到
}

// 6. 删除操作 (Delete) - 这是一个非常好的逻辑练习
void hash_table_delete(HashTable* ht, int key) {
    int index = hash(key);
    Node* current = ht->buckets[index];
    Node* prev = NULL;
    
    while (current != NULL) {
        if (current->key == key) {
            if (prev == NULL) {
                // 如果要删的是链表头
                ht->buckets[index] = current->next;
            } else {
                // 如果在链表中间或尾部
                prev->next = current->next;
            }
            free(current);
            printf("Deleted key %d from Index %d\n", key, index);
            return;
        }
        prev = current;
        current = current->next;
    }
}

// --- 测试 ---
int main() {
    HashTable ht;
    // 初始化哈希表，将所有桶置为空
    for (int i = 0; i < BUCKET_COUNT; i++) ht.buckets[i] = NULL;

    printf("--- Building Hash Table ---\n");
    hash_table_insert(&ht, 1, 95);  // Index 1
    hash_table_insert(&ht, 11, 88); // Index 1 (发生冲突！)
    hash_table_insert(&ht, 21, 70); // Index 1 (再次冲突！)
    hash_table_insert(&ht, 5, 100); // Index 5

    printf("\n--- Searching ---\n");
    int val = hash_table_search(&ht, 11);
    if (val != -1) printf("Found Key 11 with Value: %d\n", val);
    else printf("Key 11 not found.\n");

    printf("\n--- Deleting ---\n");
    hash_table_delete(&ht, 11);
    
    val = hash_table_search(&ht, 11);
    if (val != -1) printf("Found Key 11 after delete: %d\n", val);
    else printf("Key 11 not found after delete.\n");

    return 0;
}
```

---

## 💡 助教的深度感悟

1.  **关于 $O(1)$ 的真相**：
    散列表的 $O(1)$ 是**期望（Average Case）**时间。在极端倒霉（或者黑客故意攻击）的情况下，它可能退化成 $O(n)$。所以，哈希函数的设计就是为了逃离“墨菲定律”。

2.  **为什么 Python/Java 的字典那么快？**
    因为它们内部实现了非常复杂的动态扩容机制。当哈希表太满时（装载因子 $\alpha > 0.7$），它会自动申请一个更大的数组并重新分配（Rehash）。

3.  **天才的权衡**：
    *   数组（直接寻址）：极快，但浪费空间。
    *   链表：慢，但省空间。
    *   **哈希表**：通过哈希函数，在速度和空间之间找到了那个**黄金平衡点**。
