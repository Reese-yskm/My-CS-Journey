# 图论基础 (Graph Foundations)

## 1. 数学定义
图（Graph）由两个集合组成：$G = (V, E)$。
*   **$V$ (Vertices/Nodes)**：**顶点**集合。代表实体（如：城市、用户、计算机）。
*   **$E$ (Edges)**：**边**集合。代表实体之间的关系（如：道路、好友关系、网线）。

---

## 2. 图的基本分类

### 2.1 无向图 (Undirected Graph)
*   **特性**：边是对称的。如果存在边 $(u, v)$，则可以从 $u$ 到 $v$，也可以从 $v$ 到 $u$。
*   **例子**：微信好友。如果你是我的好友，我也一定是你的好友。

### 2.2 有向图 (Directed Graph / Digraph)
*   **特性**：边是有方向的。由一个**有序对** $\langle u, v \rangle$ 表示，从 $u$ 指向 $v$。
*   **例子**：微博关注。我关注了你，但你未必关注我。

### 2.3 加权图 (Weighted Graph)
*   **特性**：每条边都有一个与之关联的数值（权重 $w$）。
*   **例子**：地图导航。边代表道路，权重代表路程长度或通过时间。

---

## 3. 顶点的度 (Degree) —— 重要概念

*   **无向图中**：一个顶点的“度”是与之相连的边的总数。
*   **有向图中**：
    *   **入度 (In-degree)**：指向该顶点的边的数量。
    *   **出度 (Out-degree)**：从该顶点出发的边的数量。
*   **握手定理 (Handshaking Lemma)**：在无向图中，所有顶点的度数之和等于总边数的 **2 倍**。
    *   *感悟*：每条边都被计算了两次（两头各一次）。

---

## 4. 路径与环 (Paths and Cycles)

*   **路径 (Path)**：一个顶点序列，其中每两个相邻顶点之间都有边连接。
*   **简单路径 (Simple Path)**：序列中所有顶点都互不相同的路径。
*   **环 (Cycle)**：起点和终点相同的路径。
*   **有向无环图 (DAG, Directed Acyclic Graph)**：**极其重要**。它是拓扑排序的前提，也是动态规划在图论中的载体。

---

## 5. 连通性 (Connectivity)

*   **无向图连通**：如果图中任意两点之间都存在路径。（最少需要n-1条边）
*   **有向图强连通 (Strongly Connected)**：任意两点 $u, v$ 之间，既存在从 $u$ 到 $v$ 的路径，也存在从 $v$ 到 $u$ 的路径。（最少需要n条边）
*   **强连通分量 (SCC)**：有向图中极大的强连通子图。

---

## 6.图的表示

### 6.1、 邻接矩阵 (Adjacency Matrix) —— “简单粗暴的棋盘”

**物理直观：**
想象一个 $N \times N$ 的大棋盘，横坐标代表“起点”，纵坐标代表“终点”。
*   如果起点 $i$ 到终点 $j$ 有路，就在坐标 $(i, j)$ 填上 `1`（或者边的权重）。
*   如果没有路，就填 `0` 或 `∞`。

**C++ 实现：**
```cpp
int graph[1005][1005]; // 简单二维数组
```

**优缺点分析：**
*   **优点（爽在哪）：**
    1.  **极速查询**：想知道 $i$ 和 $j$ 认识吗？直接看 `graph[i][j]`，时间复杂度 $O(1)$。
    2.  **适合稠密图**：如果边非常多（接近 $N^2$），矩阵存得最整齐。
*   **缺点（坑在哪）：**
    1.  **空间黑洞**：如果你有 10 万个点，矩阵需要 $10^{10}$ 个位置，内存直接爆掉（通常内存限制只能开到 5000 左右的矩阵）。
    2.  **遍历低效**：你想找“张三的所有朋友”，你必须把张三那一整行（$N$ 个位置）都扫一遍，哪怕他只有一个朋友。

---

### 6.2、 邻接链表 (Adjacency List) —— “私人定制的通讯录”

**物理直观：**
每个点都有一个自己的“通讯录”（动态数组或链表），只记录和自己相连的那些点。
*   点 1：{2, 5}
*   点 2：{1, 3, 4}
*   ...

**C++ 实现（工业级/常用写法）：**
```cpp
vector<int> adj[100005]; // 每个点都有一个 vector
// 加边：adj[u].push_back(v);
```

**优缺点分析：**
*   **优点（强在哪）：**
    1.  **极其省空间**：你有多少条边，就占多少空间。空间复杂度 $O(N + E)$，适合**稀疏图**。
    2.  **找邻居极快**：想找“张三的朋友”？直接遍历 `adj[张三]`，里面全是精准名单，没有废话。
*   **缺点（难在哪）：**
    1.  **查询慢**：想知道 $i$ 和 $j$ 连不连？得把 `adj[i]` 扫一遍。
    2.  **结构稍复杂**：涉及 `vector` 或链表操作。

---

### 6.3、 进阶：链式前向星 (Static Linked List) —— “南大选手的标配”

学弟，这个你一定要重点看。在南大的算法竞赛或者高性能开发中，我们既不喜欢二维数组（太浪费），也不太喜欢 `vector`（动态分配内存有开销）。
我们喜欢用**数组模拟链表**，这种方法叫**“链式前向星”**。

**它的核心思想是：** 用数组存所有的边，每条边都记录“我指向谁”以及“跟我同起点的上一条边在哪”。

**代码实现：**
```cpp
struct Edge {
    int to;       // 这条边指向哪里
    int next;     // 和这条边同起点的“上一条边”的编号
    int weight;   // 边权
} edge[500005];   // 总边数

int head[100005]; // head[u] 存储点 u 的“最后一条边”的编号
int cnt = 0;      // 总边数计数

void add_edge(int u, int v, int w) {
    cnt++;
    edge[cnt].to = v;
    edge[cnt].weight = w;
    edge[cnt].next = head[u]; // 指向 u 之前连的那条边
    head[u] = cnt;            // 更新 u 的最后一条边为当前这一条
}

// 遍历 u 的所有邻居
for (int i = head[u]; i != 0; i = edge[i].next) {
    int v = edge[i].to;
    // 处理邻居 v...
}
```

**为什么 NJU 拔尖班大佬爱用这个？**
1.  **速度极致**：纯数组操作，没有 `vector` 的动态开销。
2.  **内存可控**：开多大数组是一次性定死的，不会因为内存碎片导致程序崩掉。
3.  **适合所有图算法**：它是以后你学 Dijkstra、网络流、拓扑排序的黄金拍档。

---

### 6.4、 总结与建议（点拨迷津）

对于你现在这个阶段：

1.  **小规模图（点数 < 5000）**：别犹豫，直接**邻接矩阵**，写起来最快，不易出错。
2.  **大规模稀疏图（点数达 10 万）**：用 `vector<int> adj[N]`，这是**性价比最高**的写法。
3.  **追求极致性能/参加校赛**：一定要掌握**链式前向星**。

