# 图算法 

### 一、 DFS (Depth First Search)：执着的迷宫探索者

**1. 物理直觉：**
想象你在走一个复杂的迷宫。DFS 的策略是：**“不撞南墙不回头”**。
*   你从起点出发，选定一条路一直往下走。
*   直到走到死胡同，或者发现这块地儿已经走过了，你才会**回溯（Backtrack）**到上一个路口，选另一条路再试。

**2. 核心工具：栈 (Stack) / 递归**
*   DFS 天然适合用**递归**来实现，因为递归本身就是利用系统栈来记录“回家的路”。

**3. 代码模板：**
```cpp
bool visited[MAXN]; // 标记数组，防止无限循环

void dfs(int u) {
    visited[u] = true; // 1. 标记当前点已访问
    cout << u << " ";  // 2. 执行操作（比如打印）

    for (int v : adj[u]) { // 3. 遍历所有邻居
        if (!visited[v]) { // 4. 如果邻居没去过
            dfs(v);        // 5. 递归潜入
        }
    }
}
```

---

### 二、 BFS (Breadth First Search)：扩散的涟漪

**2. 物理直觉：**
想象你往平静的湖面投了一块石头。BFS 的策略是：**“地毯式搜索”**。
*   你先访问离起点最近的一层点（1步能到的）。
*   再访问第二层点（2步能到的）……
*   **BFS 的核心优势：** 在无向图中，它第一次搜到某个点时，所经过的路径一定是**最短路径**。

**2. 核心工具：队列 (Queue)**
*   先进先出 (FIFO)。先发现的先排队，先排队的先处理邻居。

**3. 代码模板：**
```cpp
void bfs(int start) {
    queue<int> q;
    q.push(start);
    visited[start] = true;

    while (!q.empty()) {
        int u = q.front();
        q.pop();
        cout << u << " ";

        for (int v : adj[u]) {
            if (!visited[v]) {
                visited[v] = true; // 入队时立即标记，防止重复入队
                q.push(v);
            }
        }
    }
}
```

---

### 三、 这个下午你的三个挑战任务

为了彻底搞懂，建议你按顺序完成这三个练习：

#### 任务 1：走通遍历
用你昨天写的邻接表存图，分别调用 `dfs(1)` 和 `bfs(1)`，观察输出的节点顺序有什么不同。
*   *思考：* 为什么 DFS 看起来总是“深不可测”，而 BFS 看起来“稳扎稳打”？

#### 任务 2：寻找“最短路径” (BFS 的神技)
**题目：** 给定一个无向图，求从节点 A 到节点 B 最少要经过几条边？
*   *点拨：* 在 BFS 时，增加一个 `dist[v] = dist[u] + 1`，记录每个点距离起点的步数。

#### 任务 3：检测环 (DFS 的应用)
**题目：** 判断一个无向图中是否存在环？
*   *点拨：* 在 DFS 时，如果发现一个邻居已经被 `visited` 了，且这个邻居不是你的“亲爹”（上一个递归跳过来的点），那说明你通过另一条路绕回来了——这就是环！

---

### 四、 南大学长的“职场视角”点拨

在深圳的大厂面试里，面试官很少直接问“请默写 DFS”，他们会把这两个算法包装在实际场景中：

*   **场景 A：** “微信想开发一个功能，展示你和某个陌生人之间有几个共同好友，或者是‘几度人脉’，你会选哪个算法？”
    *   *答案：* **BFS**。因为这本质上是找社交关系图中的最短步数。
*   **场景 B：** “手机系统的文件管理器要统计某个文件夹下所有文件的大小，怎么做？”
    *   *答案：* **DFS**。因为文件夹是一棵树，深层嵌套最适合递归。

